var mind = import UI/MindstoneButton
mind.SetXY(1,6)

import Cosmetics/PetStonehead



/* *** IMPORTS *** */

// VARIABLES:

//Units

var sec = 30 // frames
var scr = 69 // 1 screen = 69 units

// VARIABLES:

// Units

var sec = 30
var scr = 69



// FUNCTIONS:

func max(n1,n2)
  ?n1 >= n2
    return n1
  :
    return n2

func getLargestStr(arrStr)
  ?arrStr.Count() > 0
    var maxStr = arrStr[0]
    var maxInd = -1

    for str : arrStr
      ?string.Size(str) > string.Size(maxStr)
        maxStr = str

    return maxStr
  
  :
    return null

func replaceInStr(str, charOld, charNew)
  for i = 0 .. str.Count() - 1
    ?str[i] = charOld
      str[i] = charNew

  return str


func myFormatDigital(frames)
  ?frames <= 0
    return "00:00"
  :
    var timeStr
    var secs
    var mins
    var secStr
    var minStr

    secs = frames/30
    mins = (frames/30)/60

    secs -= mins*60

    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins
      
    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
    
    return minStr + ":" + secStr

func formatSpeedrun(frames)

  var timeStr = "00:00 00f"

  ?frames > 0

    var frms
    var secs
    var mins
    var frmStr
    var secStr
    var minStr

    frms = frames % 30 // the rest of the division is the added frames between each second
    secs = frames/30
    mins = (frames/30)/60

    secs -= mins*60

    frmStr = frms + "f"

    ?frms < 10
      frmStr = "0" + frms + "f"
    :
      frmStr = frms + "f"

    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
      
    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins

    timeStr = minStr + ":" + secStr + " " + frmStr
    
  return timeStr



// VARIABLES - definitions


//Location
var l = loc
var ls = loc.stars
var lavg = loc.averageTime
var lbt = loc.bestTime
var lb = loc.begin
var ll = loc.loop

// Foe
var f
f = foe
var fn
var fbs
var fds
var fd
var fc
var fs
var ft
var fhp
fhp = foe.hp
var fa
fa = foe.armor
var fdmg
var fmhp

// Time
var tt
tt = totaltime

// Item
var ip
ip = item.potion
var il
il = item.left
var ils
ils = item.left.state
var ilt
var ili

var ir
ir = item.right
var irs
irs = item.right.state
var irt
var iri

// Player stats
var php
var pmhp
var pa
var pma
var ds
var bs

// Ai
var aiE
var aiI
aiI = ai.idle

//screen
var si
si = screen.i

//resources
var rs
var rw
var rt
var rb
var rk
var rc

// Functions
var canAct
canAct = item.CanActivate()

// Cooldowns
var bladeCd = 80 * sec
var maskCd = 48 * sec
var armCd = 39 * sec
var fTaliCd = 5 * sec
var aeTaliCd = 5 * sec
var cindCd = 90 * sec
var weavCd = 90 * sec

var bardCd = 30 * sec
var hammCd = 22 * sec
// var mindCd = 12 * sec // currently not in use
var qstaffCd = 5 * sec + 15 // 5,5s
var dashCd = sec + 15 // 1,5s
var bashCd = 9 * sec

// Cast times
var castTime = sec

// Delays
var bladeDelay = 0
var maskDelay = 0
var armDelay = 0
var fTaliDelay = 0
var aeTaliDelay = 0
var cindDelay = 0
var weavDelay = 0

var bardDelay = 0
var hammDelay = 0
// var mindDelay = 0 // currently not in use
var qstaffDelay = 0
var dashDelay = 0
var bashDelay = 0

?tt < 3
  lb = loc.begin
  ll = loc.loop

?tt = 1
  lavg = loc.averageTime
  lbt = loc.bestTime

  bladeDelay = 0
  maskDelay = 0
  armDelay = 0
  fTaliDelay = 0
  aeTaliDelay = 0
  cindDelay = 0
  weavDelay = 0

  bardDelay = 0
  hammDelay = 0
  // mindDelay = 0 // currently not in use
  qstaffDelay = 0
  dashDelay = 0
  bashDelay = 0



// FUNCTIONS

func mkPanel(x,y,w,h, anchor,dock, col,style, child)

  var panel

  panel = ui.AddPanel()

  panel.x = x
  panel.y = y

  ?w
    panel.w = w
  ?h
    panel.h = h

  panel.anchor = anchor
  panel.dock = dock

  ?col
    panel.color = col
  ?style
    panel.style = style

  ?child
    panel.Add(child)

  return panel

func mkTxtbox(x,y,w,h, anchor,dock, txt, align, col)

  //declarations:
  var txtbox

  //assignations:
  txtbox = ui.AddText(txt)

  //adding alignment
  txtbox.anchor = anchor
  txtbox.dock = dock

  ?align
    txtbox.align = align

  //adding color
  ?col
    txtbox.color = col

  //adding position
  txtbox.x = x
  txtbox.y = y

  //adding width and height
  ?w
    txtbox.w = w
  :
    txtbox.w = string.Size(
    ^            getLargestStr(
    ^              string.Split(txt, "\n")))
    
  ?h
    txtbox.h = h
  :
    txtbox.h = string.Split(txt, "\n").Count()


  return txtbox

func mkBtn(x,y,w,h, anchor,dock, txt, col,tcol,bcol,hcol, style, pressed,down,up, sound)
  
  var btn
  btn = ui.AddButton()

  btn.x = x
  btn.y = y

  btn.text = txt

  ?w
    btn.w = w
  :
    var txtSize = string.Size(txt)
    var parity = txtSize % 2
    ?parity = 0 // even
      btn.w = (txtSize * 2) + 2 // *2 = always even, 2 for even margin
    : // odd
      btn.w = (txtSize * 2) + 3 // *2 + 1 = always odd, 3 for odd margin

  ?h
    btn.h = 3 + h
  :
    btn.h = 3


  ?anchor
    btn.anchor = anchor
  ?dock
    btn.dock = dock

  ?style
    btn.style = style

  ?tcol
    btn.tcolor = tcol
  :
    btn.tcolor = col
  ?bcol
    btn.bcolor = bcol
  :
    btn.bcolor = col
  ?hcol
    btn.hcolor = hcol
  :
    btn.hcolor = col

  btn.SetPressed(pressed)
  ?down
    btn.SetDown(down)
  ?up
    btn.SetUp(up)

  ?sound
    button.sound = sound

  return btn



// VARIABLES:

//poison:
var dPsword1 = "poison sword dP *max +13" // enchanted: speed
var dPsword2 = "poison sword dP +0" // enchanted: debuff
var psword = "poison sword D *max"
var pshield = "poison shield A *max"
var pBow = "poison bow -dP *max"
var dPbow = "poison bow dP *max"
var dPwand = "poison wand dP *max"

//vigor:
var dLsword = "vigor sword dL *max"
var vsword = "vigor sword D *max Spring24"
var vshield = "vigor shield A *max"
var ahShield = "vigor shield ah *max"
var ahHammer = "vigor hammer ah *max"
var vwand1 = "vigor wand D *max +10"
var vwand2 = "vigor wand D *max +9"

//aether:
var aesword = "aether sword D *max"
var dUsword1 = "aether sword dU *max +15 -big"
var dUSWORD2 = "big aether sword dU *max +15"
var aeshield = "aether shield -au *max"
var auShield = "aether shield au *max"
var aebow = "aether crossbow D *max"
var dUstaff = "aether staff dU *max"
var dUwand = "aether wand dU *max"

//fire:
var dFsword = "fire sword dF *max"
var fsword = "fire sword D *max"
var fshield = "fire shield A *max"
var fbow = "fire crossbow dF *max"
var dFwand = "fire wand dF *max"

//ice:
var dIsword = "ice sword dI *max"
var isword = "ice sword D *max"
var ishield = "ice shield A *max"
var aiShield = "ice shield ai *max"
var dIwand1 = "ice wand dI *max +16"
var dIwand2 = "ice wand dI *max +11"
var ibow = "ice crossbow D *max"

//alternate:
var altbow = "crossbow *max golden"

//special weapons:
var dshield = "dashing shield *max golden HoH24"
var myqstaff = "quarterstaff golden"
var fastBard = "bardiche *max" // enchanted: speed
var rbow = "repeating crossbow *max golden"
var cshield1 = "compound shield *max shiny"
var cshield2 = "compound shield *max -shiny"
var tshield = "towering shield *max golden"



// Weapons damage and stats

var bladeDmg = 310
var bladeRDmg = 95
var smiteMult = 8.8 // mult = multiplier

var armDmg = 44
var armRDmg = armDmg / 2
var maxArmBuffs = 3

var cindDmg = 32 // multiplied by the amount of Ignition buffs
var maxIgnitions = 15

var weavDmg = 1
var weavUnmkChance = 0.12 // %
var weavArmor = 1.35

var hammDmg = 123

var bardDmg = 52
var bardCrit = 10.8
var bardRDmg = (bardDmg + 17) * bardCrit



// VARIABLES:

// Times in seconds:
var ttDigital = myFormatDigital(tt)
var pb = myFormatDigital(lbt)
var avg = myFormatDigital(lavg)

// Times in seconds and frames:
var ttSpeedrun = formatSpeedrun(tt)
var pbSpeedrun = formatSpeedrun(lbt)
var avgSpeedrun = formatSpeedrun(lavg)


// Variable updating frequency:
?tt % 30 = 0
  ttDigital = myFormatDigital(tt)
ttSpeedrun = formatSpeedrun(tt)

?loc.loop
  pb = myFormatDigital(lbt)
  avg = myFormatDigital(lavg)

  pbSpeedrun = formatSpeedrun(lbt)
  avgSpeedrun = formatSpeedrun(lavg)



// PUBLIC FUNCTIONS

func speedOmeterUpdate(isSpeedrun)
  ?isSpeedrun
    return true
  :
    return loc.begin | loc.loop | (tt % 30 = 0)

func speedOmeterToStr(isSlim, isSpeedrun)

  ?isSlim
    ?isSpeedrun
      return
      ^"☆ " + pbSpeedrun +  // ☆ = PB
      ^" | ≈ " + avgSpeedrun + // ≈ = AVG
      ^" | ▶ " + ttSpeedrun           // ▶ = CURR

    :
      return
      ^"☆ " + pb +       // ☆ = PB
      ^" | ≈ " + avg +      // ≈ = AVG
      ^" | ▶ " + ttDigital         // ▶ = CURR

  :
    ?isSpeedrun
      return
      ^"    SPEED-O-METER" + "\n" +
      ^"·····················" + "\n" +
      ^" PB  " + pbSpeedrun + " (" + lbt + "f)" + "\n" +
      ^" AVG " + avgSpeedrun + " (" + lavg + "f)" + "\n" +
      ^" CUR " + ttSpeedrun + " (" + tt + "f)"

    :
      return
      ^"SPEED-O-METER" + "\n" +
      ^"·············" + "\n" +
      ^"  PB  " + pb + "\n" +
      ^"  AVG " + avg + "\n" +
      ^"  CUR " + ttDigital

func printSpeedOmeter(x, y, col, isSlim, isSpeedrun)

  >`@x@,@y@,@col@,@speedOmeterToStr(isSlim, isSpeedrun)@

  return

func asciiPrintSpeedOmeter(x, y, col, isSlim, isSpeedrun)

  >`@x@,@y@,@col@,ascii
@replaceInStr(speedOmeterToStr(isSlim, isSpeedrun), " ", "#")@
asciiend

  return

func speedOmeterUI(x, y, col, isSlim, isSpeedrun)

  var txt
  var panel

  // For the panel:
  var pnlAnchor
  var pnlDock
  var style
  
  ?isSlim
    pnlAnchor = top_center
    pnlDock = top_center
    style = -1
  :
    pnlAnchor = top_left
    pnlDock = top_left
    style = -2

  txt = mkTxtbox(
    ^1, 1, null, null, // x, y, w, h,
    ^top_left, top_left, // pnlAnchor, dock,
    ^speedOmeterToStr(isSlim, isSpeedrun), // txt
    ^null, col) // align, col

  panel = mkPanel(
    ^x, y, txt.w + 2, txt.h + 2, // x, y, w, h,
    ^pnlAnchor, pnlDock, // anchor, dock,
    ^col, style, txt) // col, style, child

  return panel



// PUBLIC VARIABLES

var DPSMeterEnabled = false


// GLOBAL VARIABLES

var currhp = 0
var nethp = 0

currhp = fhp + fa
nethp  = foe.maxhp + foe.maxarmor

var hits      = 0
var dmg       = 0
var totalDmg  = 0
var startTime = 0
var auxhp     = 0

var FRM = "N/A"
var FPH = "N/A"
var HPS = "N/A"
var DPF = "N/A"
var DPS = "N/A"



// PROCEDURE

// Calculate only when desired:
?DPSMeterEnabled

  ?f = "boss" // only works when there's a boss

    ?0 < currhp & currhp < nethp // boss lost hp/armor, but isn't dead

      ?auxhp > currhp // if current hp updates
        hits += 1 // we count a hit
        dmg       = auxhp - currhp // we get the damage dealt from the difference
        totalDmg  = totalDmg + dmg // and we accumulate it in this variable
  
    : // else, reset temporal variables
      startTime = tt
      hits      = 0
      dmg       = 0
      totalDmg  = 0


    FRM = tt - startTime // total time minus the time the first hit was dealt
    ?hits > 1
      FPH = FRM      / (hits-1) // -1 is there to avoid stat flicking
    :
      FPH = "N/A"
  
    ?FPH ! "N/A"
      HPS = sec      / FPH
    :
      HPS = "N/A"
      
    ?FRM > 0
      DPF = totalDmg / FRM // damage accumulated - no. frames elapsed
    :
      DPF = "N/A"

    ?DPF ! "N/A"
      DPS = DPF  * sec
    :
      DPS = "N/A"



// PRIVATE FUNCTIONS (do not use/modify!)

func dpsUpdate()
  ?DPSMeterEnabled
    auxhp = currhp

  return


var hits_old
var HPS_old
var dmg_old
var DPF_old
var DPS_old



// PUBLIC FUNCTIONS

func dpsMeterUpdate(mode)
  var result = false

  ?DPSMeterEnabled
    ?f = "boss"
      
      ?mode = 1
        ?(hits_old ! hits | HPS_old ! HPS |
        ^dmg_old ! dmg | DPF_old ! DPF |
        ^DPS_old ! DPS)
          ?hits_old ! hits
            hits_old = hits
          ?HPS_old ! HPS
            HPS_old = HPS
          ?dmg_old ! dmg
            dmg_old = dmg
          ?DPF_old ! DPF
            DPF_old = DPF
          ?DPS_old ! DPS
            DPS_old = DPS

          result = true


      :?mode = 2 &
      ^DPS_old ! DPS
        DPS_old = DPS

        result = true

  return result


func uiDPSMeter(x,y,colorStr,mode)
  var panel
  var txt
  
  ?DPSMeterEnabled & (mode = 1 | mode = 2)

    panel = ui.AddPanel()

    var dpsStr
    ?mode = 1
      dpsStr = "   DPS METER   "   + "\n" +
      ^        "···············"   + "\n" +
      ^        " hits     " + hits_old + "\n" +
      ^        " hits/s   " + HPS_old  + "\n" +
      ^        " dmg /hit " + dmg_old  + "\n" +
      ^        " dmg /f   " + DPF_old  + "\n" +
      ^        " dmg /s   " + DPS_old  + "\n" +
      ^        "···············"

    :?mode = 2
      dpsStr = "DPS | " + DPS_old

    txt = ui.AddText(dpsStr)


    panel.style = 3
    panel.Add(txt)
    
    ?mode = 1
      panel.anchor = top_left
      panel.dock = top_left
      txt.anchor = top_left
      txt.dock = top_left

    :?mode = 2
      panel.anchor = top_center
      panel.dock = top_center
      txt.anchor = top_left
      txt.dock = top_left
      
    
    panel.color = colorStr
    txt.color = colorStr


    panel.x = x
    panel.y = y
    
    txt.x = 1
    txt.y = 1
    
    ?mode = 1
      txt.w = 15
      txt.h = 8

    :?mode = 2
      txt.w = string.Size(dpsStr)
      txt.h = 1


    panel.w = txt.w + 2
    panel.h = txt.h + 2


    dpsUpdate()


  ?mode ! 1 & mode ! 2
    >c0,0,#red,func uiDPSMeter() - incorrect mode: @mode@

  return panel



// FUNCTIONS

// Helper functions

func colToHex(colName)
  ?colName = "red"
    return #FF0000
  :?colName = "orange"
    return #FF7518
  :?colName = "yellow"
    return #FFFF00
  :?colName = "gold"
    return #E49B0F
  :?colName = "blue"
    return #0000FF
  :?colName = "cyan"
    return #00FFFF
  :?colName = "magenta"
    return #FF00FF
  :?colName = "pink"
    return #E0115F
  :?colName = "purple"
    return #800080
  :?colName = "violet"
    return #7F00FF
  :?colName = "green"
    return #008000
  :?colName = "darkGreen"
    return #023020
  :?colName = "white"
    return #FFFFFF
  :?colName = "gray"
    return #808080
  :?colName = "black"
    return #000000
  :?colName = "brown"
    return #7B3F00
  :?colName = "turquoise" | colName = "turquesa"
    return #40E0D0
  :?colName = "rainbow" | colName = "rgb"
    return #rainbow
  :
    >c-20,0,#red,ERROR: colToHex() got unexisting color: @colName@


// Stats

func getBuffInfo(nameid, inFoe, infoIndex)
  var info
  var buffFound
  var arrBuffs


  // if inFoe = true, checks foe's buffs, else, player's buffs
  ?inFoe
    arrBuffs = string.Split(fbs,",", true)
  :
    arrBuffs = string.Split(bs,",", true)
    
  ?arrBuffs & !buffFound
    for buff : arrBuffs
      ?buff = nameid
        var arrInfo = string.Split(buff,":",true)


        ?0 <= infoIndex & infoIndex <= 3
          info = int.Parse(arrInfo[infoIndex])


        buffFound = true


    ?buffFound = true
      return info
    :
      return 0

func getDebuffLvl(nameid,inFoe)
  var lvl
  var debuffFound
  var arrDebuffs


  // if inFoe = true, checks foe's debuffs, else, player's debuffs
  ?inFoe
    arrDebuffs = string.Split(fds,",", true)
  :
    arrDebuffs = string.Split(ds,",", true)


  ?arrDebuffs & !debuffFound
    for debuff : arrDebuffs
      ?debuff = nameid
        var arrInfo = string.Split(debuff,":",true)


        lvl = int.Parse(arrInfo[2])
        debuffFound = true


    ?debuffFound = true
      return lvl
    :
      return 0


func showDebuffs(inFoe,x,y,col,isUI)
  ?(inFoe & fds)
  ^|(!inFoe & ds)
    var arrDebuffs


    ?inFoe
      arrDebuffs = string.Split(fds,",", true)
    :
      arrDebuffs = string.Split(ds,",",true)


    ?arrDebuffs
      ?isUI
        var debuffsTxtbox
        var debuffsPanel
        var debuffsStr = "Debuffs:\n"

        for debuff : arrDebuffs
          var arrInfo = string.Split(debuff,":",true)

          debuffsStr += arrInfo[0] + "(" + arrInfo[1] + ") = " + arrInfo[2] + "\n"
        
        debuffsTxtbox = mkTxtbox(
          ^1,1,null,null, // x,y,w,h
          ^top_left,top_left, // anchor, dock
          ^debuffsStr, // txt
          ^null,col) // align, col
        

        debuffsPanel = mkPanel(
        ^x,y,
        ^debuffsTxtbox.w + 1, // w
        ^debuffsTxtbox.h + 1, // h
        ^top_left,top_left, // anchor, dock
        ^col,1, // col, style
        ^debuffsTxtbox) // child

        return debuffsPanel

      :
        >`@x@,@y@,@col@,Debuffs:
        var i = 0
        for debuff : arrDebuffs
          var arrInfo = string.Split(debuff,":",true)


          >`@x@,@y+1 + i@,@col@,  @arrInfo[0]@ (@arrInfo[1]@) = @arrInfo[2]@
          i++
        
        return

  :
    return

func showBuffs(inFoe,x,y,col,isUI)
  ?(inFoe & fbs)
  ^|(!inFoe & bs)
    var arrBuffs


    ?inFoe
      arrBuffs = string.Split(fbs,",", true)
    :
      arrBuffs = string.Split(bs,",",true)


    ?arrBuffs
      ?isUI
        var buffsTxtbox
        var buffsPanel
        var buffsStr = "Buffs:\n"

        for buff : arrBuffs
          var arrInfo = string.Split(buff,":",true)

          buffsStr += arrInfo[0] + "(" + arrInfo[1] + ") = " + arrInfo[2] + "\n"
        
        buffsTxtbox = mkTxtbox(
          ^1,1,null,null, // x,y,w,h
          ^top_left,top_left, // anchor, dock
          ^buffsStr, // txt
          ^null,col) // align, col
        

        buffsPanel = mkPanel(
        ^x,y,
        ^buffsTxtbox.w + 1, // w
        ^buffsTxtbox.h + 1, // h
        ^top_left,top_left, // anchor, dock
        ^col,1, // col, style
        ^buffsTxtbox) // child

        return buffsPanel

      :
        >`@x@,@y@,@col@,Buffs:
        var i = 0
        for buff : arrBuffs
          var arrInfo = string.Split(buff,":",true)


          >`@x@,@y+1 + i@,@col@,  @arrInfo[0]@ (@arrInfo[1]@) = @arrInfo[2]@
          i++
        
        return

  :
    return

func showEffects(isBuff,inFoe,x,y,col,isUI)
  ?isBuff
    ?isUI
      return showBuffs(inFoe,x,y,col,true)
    :
      showBuffs(inFoe,x,y,col,false)
      return
  :
    ?isUI
      return showDebuffs(inFoe,x,y,col,true)
    :
      showDebuffs(inFoe,x,y,col,false)
      return


func getFoeTotalHP()
  return fhp + fa


// Strings

func showBigStr(x,y,maxW,str,col,isUI)

  ?isUI
    var txtbox
    var panel

    txtbox = mkTxtbox(1,1,maxW,null,
    ^top_left,top_left,
    ^str,null,col)

    panel = mkPanel(x,y,
    ^txtbox.w + 2,
    ^txtbox.h + 2,
    ^top_left,top_left,
    ^col,-1,txtbox)
    
    return panel
  
  :
    var arr = string.Break(str, maxW)

    for i = 0 .. arr.Count()-1
      ?col
        >`@x@,@y + i@,@col@,@arr[i]@
      :
        >`@x@,@y + i@,@arr[i]@

    return

func showStrCtr(y,maxW,str,col,isUI)

  ?isUI
    var txtbox
    var panel

    txtbox = mkTxtbox(1,1,maxW,null,
    ^top_left,top_left,
    ^str,center,col)

    panel = mkPanel(
    ^- (txtbox.w / 2),y,
    ^txtbox.w + 2,
    ^txtbox.h + 2,
    ^center_center,center_centere,
    ^col,-1,txtbox)
    
    return panel

  :

    var arr = string.Break(str, maxW)

    for i = 0 .. arr.Count()-1
      var x
      x = - ( string.Size(arr[i]) - 1 ) / 2
      ?col
        >c@x@,@y + i@,@col@,@arr[i]@
      :
        >c@x@,@y + i@,@arr[i]@

    return



// VARIABLES

// Status

pmhp = maxhp // PRIVATE - to save sys variable accesses (and reduce lag)

var midhp = pmhp / 2
var lowhp = pmhp / 3
var hihp = (4 * pmhp) / 5



// FUNCTIONS


// Lost items

func canUseBlade()
  return tt >= bladeDelay & canAct

func useBlade()
  equip blade
  activate R

  bladeDelay = tt + bladeCd

  return

func canUseBladeDS(nScreen)
  return canUseBlade()
  ^& si = nScreen

var slideCount = 0 // counter to give screen.Next() time to slide
func useBladeDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useBlade()
      screen.ResetOffset()
      return


func canUseArm()
  return tt >= armDelay &
  ^3 <= fd & fd <= 7
  ^& canAct

func useArm()
  equip arm
  activate R

  armDelay = tt + armCd

  return


func canUseMask()
  return tt >= maskDelay & canAct

func useMask()
  equipL triskelion
  equipR mask
  activate R

  maskDelay = tt + maskCd

  return

func canUseMaskDS(nScreen)
  return canUseMask()
  ^& si = nScreen

func useMaskDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useMask()
      screen.ResetOffset()
      return


func canUseFTali()
  return
  ^summon.GetId() ! "cinderwisp" &
  ^tt >= fTaliDelay &
  ^canAct |
  ^(il = "fire_talisman" & ils = 2) |
  ^(ir = "fire_talisman" & irs = 2)

func canHideFTali()
  return summon.GetId() = "cinderwisp"
  ^& tt >= fTaliDelay
  ^& canAct |
  ^(il = "fire_talisman" & ils = 2) |
  ^(ir = "fire_talisman" & irs = 2)

func useFTali(hand)
  ?hand = "l"
    equipL fire_talisman
    activate L
  :?hand = "r"
    equipR fire_talisman
    activate R

  fTaliDelay = tt + fTaliCd + castTime

  return

func canUseCind()
  return summon.GetId() = "cinderwisp"
  ^& tt >= cindDelay & canAct

func canKillCind(foeTotalHP,nIgnitions,cindDmg,margin)
  return foeTotalHP <= (nIgnitions * cindDmg) + margin

func useCind()
  activate cinderwisp
  cindDelay = tt + cindCd + castTime
  return


func canUseAETali()
  return
  ^summon.GetId() ! "voidweaver" &
  ^tt >= aeTaliDelay &
  ^canAct |
  ^(il = "aether_talisman" & ils = 2) |
  ^(ir = "aether_talisman" & irs = 2)

func useAETali(hand)
  ?hand = "l"
    equipL aether_talisman
    activate L
  :?hand = "r"
    equipR aether_talisman
    activate R

  aeTaliDelay = tt + aeTaliCd + castTime

  return

func canUseWeav()
  return summon.GetId() = "voidweaver"
  ^& tt >= weavDelay & canAct

func useWeav()
  activate voidweaver
  weavDelay = tt + weavCd + castTime
  return

func canUseWeavDS(nScreen)
  return canUseWeav()
  ^& si = nScreen

func useWeavDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20

  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useWeav()
      screen.ResetOffset()

      return


func canBash()
  return tt >= bashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct

func bash(lItem)
  equipL @lItem@
  equipR bashing shield

  bashDelay = tt + bashCd

  return


// Special Weapons

func canUseHamm()
  return tt >= hammDelay &
  ^canAct |
  ^(ir = "heavy hammer" &
  ^irs = 2)

var hammCdSlower
func canUseHamm2()
  hammCdSlower = item.GetCooldown("hammer") <= 0
  return hammCdSlower &
  ^canAct |
  ^(ir = "heavy hammer" &
  ^irs = 2)

func useHamm()
  equip heavy hammer
  activate R

  hammDelay = tt + hammCd + castTime

  return


func canUseBard()
  return tt >= bardDelay &
  ^canAct |
  ^(ir = "bardiche" &
  ^irs = 2)

var bardCdSlower
func canUseBard2()
  bardCdSlower = item.GetCooldown("bardiche") <= 0

  return bardCdSlower &
  ^canAct |
  ^(ir = "bardiche" &
  ^irs = 2)

func useBard(yourBard)
  ?fd < 10
    equip @yourBard@
    activate R

    bardDelay = tt + bardCd + castTime


  return


func canDash()
  return tt >= dashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct

func dash(lItem,yourDshield)
  equipL @lItem@
  equipR @yourDshield@

  dashDelay = tt + dashCd

  return


func canUseQstaff()

  ?tt >= qstaffDelay
    return canAct |
    ^(ir = "quarterstaff"
    ^& irs = 2)

  :
    return false

func canUseQstaff_OG()
  var qstaffCd_OG
  qstaffCd_OG = item.GetCooldown("quarterstaff")

  return canAct &
  ^(qstaffCd_OG <= 0 /*| qstaffCd_OG > 165*/)
  ^ | (ir = "quarterstaff" & irs = 2)

func useQstaff(yourQstaff)
  equip @yourQstaff@
  activate R

  qstaffDelay = tt + qstaffCd

  return


func canUseMind()
  return item.GetCooldown("mind") <= 0 & canAct


// Tools

func canUseHatchet()
  return item.GetCooldown("hatchet") <= 0
  ^& canAct
  ^& harvest.distance < 5
  ^& ir = "hatchet"

func useHatchet()
  activate R
  return


// Potions

func canUsePot()
  return ip ! "empty" & canAct

func canUsePotHeal()
  ?canUsePot()
    ?ip = "healing" |
    ^ip = "vampiric"
      return hp < lowhp

    :?ip = "defensive"
      return hp < midhp
    
    :
      return false
  :
    return false

func canUsePotDmg()
  return canUsePot() &
  ^(ip = "berserk" | ip = "lucky")

func canUsePotSpecial(type,cond)

  ?canUsePot()

    ?ip = type
      ?ip = "cleansing"
        return hp < midhp &
        ^debuffs.count >= cond
        // ^^^ = no. of debuffs to cleanse
    
      :?ip = "strength"
        return foe.armor & foe.armor > cond

      :?ip = "lightning"
      ^|ip = "experience"
        return foe.count >= cond

      :?ip = "invisibility"
        return f = boss

      :
        >c-10,0,#red,
        ^func canUsePotSpecial() - Potion recieved\n
        ^does not belong to this function: "@type@"
        return false

    :
      >c-10,0,#red,
      ^func canUsePotSpecial() - Potion recieved\n
      ^is not valid or equipped: "@type@"
      return false


  : // potion hasn't been brewed, it's been used,
    return false //or just can't be activated atm


// Others

var moonTimer = 0
var moonFrame
func doMoondial(weapon1, weapon2, mode)

  ?mode = 0 // Normal moondialing
    moonTimer++
    moonFrame = moonTimer % 3

    ?moonFrame = 1
      equipL moon
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?mode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moonTimer++
    moonFrame = moonTimer % 4

    ?moonFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon1@
    :?moonFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moonFrame = 4
      equipL moon
      equipR @weapon2@
  
  :?mode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@

  :?mode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    ?fd <= 5
      equipL moon
    :
      equipL @weapon2@
    equipR @weapon1@


  return



?!loc.isQuest & (
^l = "Waterfall" |
^l = "undead_crypt_intro" |
^l = "cross_deadwood_river" |
^l = "cross_bridge")
  loc.Leave()



fs = foe.state
ft = foe.time
fn = foe.name

var prebos = -1
var endbos = -1
var thebos = f

?f = "boss" & thebos ! fn
^& (irs = 2 | ils = 2)
  prebos = tt
  thebos = fn

?f = "boss" & fhp < 1 & fs ! 125 & fs ! 108
^&(f = "elementalist" & ft = 1 | ft = 0)
  endbos = tt

?endbos ! -1 & ((tt - endbos) % 10 >= 5 | key = primary)
^ & (tt - 120) <= endbos & endbos - prebos > 0
  >c-20,-10,#339999,@thebos@#killed#in#@endbos - prebos@#frames!


?totaltime - endbos = 8 & loc = "harder Angry"
  activate voidweaver



?l = "Mushroom" | l = "Waterfall"

  // VARIABLES

  var keepMask = true
  var smiteScr = 1

  var canDebI
  var canDebP
  var canDebF

  var keepFTali = false

  ?f = "phase2"
    keepFTali = true

  ?ll
    keepMask = false
    keepFTali = false

    ?tt = 1 & ls > 5 &
    ^smiteScr ! 3
      smiteScr++



  // FUNCTIONS:

  func fight1v1()
    fds = foe.debuffs.string

    /* How to apply debuffs:
    - apply all except the ones the foe is immune to.
    Finish when:
    - all possible debuffs have been applied. */
    canDebI = (fds ! "chill:6" & f ! "immune_to_debuff_chill")
    canDebP = (fds ! "damage" & f ! "immune_to_debuff_damage")
    canDebF = (fds ! "dot" & f ! "immune_to_debuff_dot")
    
    ?canDebI | canDebP | canDebF
      ?keepMask
        ?canDebI
          equipL @dIsword@
        :?canDebP
          equipL @dPsword1@
        :?canDebF
          equipL @dFsword@
      :
        //Left hand:
        ?canDebP
          equipL @dPsword1@
        :?canDebF
          equipL @dFsword@
        :?canDebI
          equipL @dIwand1@

        //Right hand:
        ?canDebI
          equipR @dIsword@
    :
      php = hp
      pmhp = maxhp

      ?keepMask
        equipL Mamba Negra

        ?php ! pmhp
          equipL @dLsword@
      :
        bs = buffs.string
        ?bs = "berserk"
          doMoondial(Mamba Negra, psword, 2)
        :
          doMoondial(Mamba Negra, psword, 0)

        ?php ! pmhp
          equipR @dLsword@

    return

  func ldtF(mode)

    ?mode = "default"
      equipL triskelion
      ?!keepMask
        equipR @cshield1@
    :?mode = "armorRegen"
      equipL triskelion
      ?!keepMask
        equipR @cshield2@
    :?mode = "engage"
      equipL triskelion
      ?!keepMask
        equipR @pshield@
    :?mode = "escape"
      equipL mind
      ?!keepMask
        equipR @pshield@
    :?mode = "magnet"
      equipL star
      ?!keepMask
        equipR triskelion

    :?mode = "meleeDmg"
      equipL Mamba Negra
      ?!keepMask
        equipR @psword@

    :?mode = "rangedDmg"
      equip @pBow@

    :?mode = "magic"
      ?keepMask
        ?canDebI
          equipL @dIwand1@
        :?canDebP
          equipL @dPwand@
        :?canDebF
          equipL @dFwand@
      :
        //Left hand:
        ?canDebP
          equipL @dPwand@
        :?canDebF
          equipL @dPwand@
        :?canDebI
          equipL @dIwand2@
        
        //Right hand:
        ?canDebI
          equipR @dIwand1@

    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@

    return



  // PROCEDURE:

  var somui = speedOmeterUI(0, 1, colToHex("pink"), true, false)
  ?speedOmeterUpdate(false)
    somui.Recycle()
    somui = null

    somui = speedOmeterUI(0, 1, colToHex("pink"), true, false)


  DPSMeterEnabled = true
  var dpsPanel
  ?dpsMeterUpdate(2)
    ?dpsPanel
      dpsPanel.Recycle()
      dpsPanel = null

    dpsPanel = uiDPSMeter(0, 4, "#yellow", 2)


  /* Mano izquierda:
  --- hacer AAC ---
  - cuando state = 3
  --- NO hacer AAC ---
  - Cuando tenemos la mascara puesta y el arma equipada es una espada D +21. */
  ?ils = 3 & !(keepMask & il = "sword D +21")
    equipL wand 0*
    equipL @il@
  ?irs = 3 & ir ! "sword D +21"
    equipR @cshield1@
    equipR @ir@

  ?hp < maxhp & !keepMask
    loc.Leave()

  ?lb
    rs = res.stone
    rw = res.wood
    rb = res.bronze

    ?rb >= 10
      ?rw >= 10
        ?ip ! "berserk"
          brew wood + bronze
      :?rs >= 10
        ?ip ! "lucky"
          brew stone + bronze
      :
        loc.Leave()
    :
      loc.Leave()

  ?keepMask
    equipR mask

  ?lb | ll
    equipL triskelion
    equipR @cshield1@

  :?canUseAETali() & !keepFTali
    ?keepMask
      useAETali("l")
    :
      equipL triskelion
      useAETali("r")

  :?canUseFTali() & keepFTali
    ?keepMask
      useFTali("l")
    :
      equipL triskelion
      useFTali("r")

  :?canUsePotDmg() & keepMask
    activate potion

  :?pickup.distance ! 9999
    ldtF("magnet")
  :
    >c-15,-2,#cyan,endbos = @endbos@
    ^\nloc = @l@
    ?tt - endbos = 8 & l = "harder Angry"
      >c0,0,#green,ACTIVATING VOIDWEAVER NOW!!!
      //useWeav()
      activate voidweaver

    fds = foe.debuffs.string
    fd = foe.distance
    fc = foe.count

    ?f = "explode"
      canDebI = (fds ! "chill:6" & f ! "immune_to_debuff_chill")
      canDebP = (fds ! "damage" & f ! "immune_to_debuff_damage")
      canDebF = (fds ! "dot" & f ! "immune_to_debuff_dot")
      
      ?fd < 7
        ldtF("escape")
      :?canDebI | canDebP | canDebF
        ldtF("magic")
      :
        ldtF("rangedDmg")

        /*?keepMask
          equipL @altbow@
        :
          ldtF("rangedDmg")*/

    :?f = "mushroom_boss" & f ! "phase2"

      ?canUsePotDmg()
        activate potion

      :?fa = foe.maxarmor & fd > 10
        ?canBash()
          bash(Mamba Negra)
        :?canDash()
          dash(Mamba Negra, dshield)
      
      :
        fs = foe.state
        ft = foe.time

        var bossDmg
        bossDmg = 168
        ?!keepMask
          bossDmg *= 2
          
        ?getFoeTotalHP() <= bossDmg | (
        ^fs = 32 & ft >= 80) // boss's punch attack
          ?canUseMask() & fd <= 10
            ldtF("escape")
          :
            ?keepMask
              equipL @dUwand@
            :
              equipL moon
              equipR @dUwand@

        :
          fight1v1()




    : // normal foes and boss's phase2
      fs = foe.state
      ?canUseBladeDS(smiteScr)
        ?fd <= 33
          useBladeDS()

      ?canUseQstaff()
        aiE = ai.enabled

        ?aiE & ir ! "heavy hammer"
        ^& ir ! "bardiche"
        ^& ir ! Kubikiribocho
        ^& (!(canBash() | canDash())
        ^| (fd < 11 | fd > 15))
          useQstaff(myqstaff)

      ?fd > 35
        pa = armor
        ?14 <= pa & pa <= 29
          ldtF("default")
        :?pa < 14
          ldtF("armorRegen")
        :
          equipL triskelion
          equipR mask

      :?fd > 15
        ldtF("engage")

        var isAbtToDash
        isAbtToDash = (fd <= 17)
        ?keepMask & isAbtToDash
          equipR @pshield@
        
        canDebI = (fds ! "chill" & f ! "immune_to_debuff_chill")
        bs = buffs.string

        ?!keepMask & canDebI & isAbtToDash &
        ^getFoeTotalHP() > getBuffInfo("smite", false, 2) * smiteMult
          equipR @aiShield@

      :?canBash()
        bash(Mamba Negra)
      :?canDash()
        dash(Mamba Negra, dshield)

      :?f ! "phase2"
        ?fc >= 5 & canUseHamm() &
        ^!canUseBlade()
          useHamm()

        :?fc = 1
          fight1v1()
        :
          canDebI = (fds ! "chill:6" & f ! "immune_to_debuff_chill")
          canDebP = (fds ! "damage" & f ! "immune_to_debuff_damage")
          canDebF = (fds ! "dot" & f ! "immune_to_debuff_dot")
          
          ?canDebI | canDebP | canDebF
            ldtF("magic")
          :?keepMask
            equipL @dPwand@
          :
            ldtF("rangedDmg")


      :?fs ! 1 // boss appearing animation
      ^&fs ! 4 // dying
        // foe = "phase2" (Enoki & Morel)

        ft = foe.time
        bs = buffs.string

        ?canUseMask()
          useMask()
        :
          fight1v1()
