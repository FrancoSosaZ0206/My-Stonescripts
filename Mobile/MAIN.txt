var sec = 30 // frames
var scr = 69 // 1 screen = 69 units


//FUNCTIONS:


func max(n1,n2)
  ?n1 >= n2
    return n1
  :
    return n2


func myFormatDigital(frames)
  ?frames <= 0
    return "00:00"
  :
    var timeStr
    var secs
    var mins
    var secStr
    var minStr


    secs = frames/30
    mins = (frames/30)/60


    secs -= mins*60


    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins
      
    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
    
    return minStr + ":" + secStr




//Location
var l = loc


var ls




// Foe
var f
f = foe
var fn
var fbs
var fds
var fd
var fs
var ft
var fhp
fhp = foe.hp
var fa
fa = foe.armor
var fdmg
var fc


// Time
var tt
tt = totaltime


// Item
var ip
ip = item.potion
var il
il = item.left
var ils
ils = item.left.state
var ilt
var ili


var ir
ir = item.right
var irs
irs = item.right.state
var irt
var iri


// Player stats
var php
var pmhp
var pa
var pma
var ds
var bs


// Ai
var aiE
var aiI
aiI = ai.idle




// Functions
var canAct
canAct = item.CanActivate()


// Cooldowns
var bladeCd = 80 * sec
var maskCd = 48 * sec
var armCd = 39 * sec
var taliCd = 5 * sec
var cindCd = 90 * sec


var bardCd = 30 * sec
var hammCd = 22 * sec
var mindCd = 12 * sec // currently not in use
var qstaffCd = 5 * sec + 15 // 5,5s
var dashCd = sec + 15 // 1,5s
var bashCd = 9 * sec


// Cast times
var castTime = sec


// Delays
var bladeDelay = 0
var maskDelay = 0
var armDelay = 0
var taliDelay = 0
var cindDelay = 0


var bardDelay = 0
var hammDelay = 0
var mindDelay = 0 // currently not in use
var qstaffDelay = 0
var dashDelay = 0
var bashDelay = 0


?tt = 1
  bladeDelay = 0
  maskDelay = 0
  armDelay = 0
  taliDelay = 0
  cindDelay = 0


  bardDelay = 0
  hammDelay = 0
  mindDelay = 0 // currently not in use
  qstaffDelay = 0
  dashDelay = 0
  bashDelay = 0










/* supports only basic colors.
Default color names from the game
(i.e. red, rainbow, cyan, etc.)
are also accepted. */
func colorToHex(colorName)
  ?colorName = red
    return #FF0000
  :?colorName = orange
    return #FF7518
  :?colorName = yellow
    return #FFFF00
  :?colorName = gold
    return #E49B0F
  :?colorName = blue
    return #0000FF
  :?colorName = cyan
    return #00FFFF
  :?colorName = magenta
    return #FF00FF
  :?colorName = pink
    return #E0115F
  :?colorName = purple
    return #800080
  :?colorName = violet
    return #7F00FF
  :?colorName = green
    return #008000
  :?colorName = darkGreen
    return #023020
  :?colorName = white
    return #FFFFFF
  :?colorName = gray
    return #808080
  :?colorName = black
    return #000000
  :?colorName = brown
    return #7B3F00
  :?colorName = turquoise | colorName = turquesa
    return #40E0D0
  :?colorName = rainbow | colorName = rgb
    return #rainbow
  :
    >c-20,0,#red,ERROR: colorToHex() got unexisting color: @colorName@




func makeTextbox(x,y,w,h,txtStr,colorName,styleID)


  //declarations:
  var panel
  var txt


  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(txtStr)




  //adding style and text to the panel:
  panel.style = styleID
  panel.Add(txt)


  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left


  //adding color
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)


  //adding position
  panel.x = x
  panel.y = y


  txt.x = 1
  txt.y = 1


  //adding wide and height
  panel.w = txt.w + w
  panel.h = txt.h + h


  return panel


func makeButton(x,y,w,h,anchor,dock,txtStr,colorName,styleID,actionFunc)
  var btn


  btn = ui.AddButton()


  btn.x = x
  btn.y = y


  btn.text = txtStr


  btn.w = string.Size(btn.text) + w
  btn.h = h


  ?anchor
    btn.anchor = anchor
  ?dock
    btn.dock = dock




  ?styleID
    btn.style = styleID


  ?colorName
    var colorID = colorToHex(colorName)
    btn.tcolor = colorID
    btn.bcolor = colorID
    btn.hcolor = colorID
  
  btn.SetPressed(actionFunc)


  return btn
  






var ttDigital = myFormatDigital(tt)
var pb = myFormatDigital(loc.bestTime)
var avg = myFormatDigital(loc.averageTime)


?tt % 30 = 0
  ttDigital = myFormatDigital(tt)
?loc.loop
  pb = myFormatDigital(loc.bestTime)
  avg = myFormatDigital(loc.averageTime)




func showTimeUI(x,y,colorName)
  var panel
  var txt
  
  panel = ui.AddPanel()
  txt = ui.AddText(
  ^    "TIME " + ttDigital
  ^+ "\nPB   " + pb
  ^+ "\nAVG  " + avg      )
  
  panel.style = 2
  panel.Add(txt)
  
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left
  
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)
  
  panel.x = x
  panel.y = y
  
  txt.x = 1
  txt.y = 1
  
  txt.w = 10


  panel.w = txt.w + 2
  panel.h = txt.h


  return panel
  




var bardTime
var hammTime
var mindTime
var stafTime
var dashTime
var bashTime


bardTime = myFormatDigital(bardDelay-tt)
hammTime = myFormatDigital(hammDelay-tt)
mindTime = myFormatDigital(mindDelay-tt)
stafTime = myFormatDigital(qstaffDelay-tt)
bashTime = myFormatDigital(bashDelay-tt)
dashTime = myFormatDigital(dashDelay-tt)


var bardTime_old
var hammTime_old
var mindTime_old
var stafTime_old
var bashTime_old
var dashTime_old


func cdUpdate()
  //if ANY cooldown changed,
  ?bardTime_old ! bardTime |
  ^hammTime_old ! hammTime |
  ^mindTime_old ! mindTime |
  ^stafTime_old ! stafTime |
  ^bashTime_old ! bashTime |
  ^dashTime_old ! dashTime
    // we update the _old variables
    bardTime_old = bardTime
    hammTime_old = hammTime
    mindTime_old = mindTime
    stafTime_old = stafTime
    bashTime_old = bashTime
    dashTime_old = dashTime
    // and return true
    return true
  : // else, we return false
    return false




func showCdownUI(x,y,colorName)


  //declarations:
  var panel
  var txt


  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(
  ^     "BARD " + bardTime
  ^ + "\nHAMM " + hammTime
  ^ + "\nMIND " + mindTime
  ^ + "\nSTAF " + stafTime
  ^ + "\nBASH " + bashTime
  ^ + "\nDASH " + dashTime )




  //adding style and text to the panel:
  panel.style = 1
  panel.Add(txt)


  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left


  //adding color
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)


  //adding position
  panel.x = x
  panel.y = y


  txt.x = 1
  txt.y = 1


  //adding wide and height


  txt.w = 10


  panel.w = txt.w + 2
  panel.h = txt.h + 3


  return panel




func showBigStrUI(str,maxwidth,x,y,colorID)


  //declarations:
  var panel
  var txt


  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(str)




  //adding style and text to the panel:
  panel.style = -1
  panel.Add(txt)


  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left


  //adding color
  ?colorID
    txt.color = colorToHex(colorID)
    panel.color = colorToHex(colorID)


  //adding position
  panel.x = x
  panel.y = y


  txt.x = 1
  txt.y = 1


  txt.w = maxwidth


  //adding wide and height
  panel.w = txt.w + 2
  panel.h = txt.h + 2


  return panel




func showStrCentered(str,y,maxW,colorName)
  ?string.Size(str) <= maxW
    >c@-(string.Size(str)-1)/2@,@y@,@colorToHex(colorName)@,@str@
  :
    var arrStr = string.Break(str,maxW)
    ?arrStr
      for i = 0 .. arrStr.Count() - 1
        >c@-(string.Size(str)-1)/2@,@y-((arrStr.Count()-1))/2+i@,@colorToHex(colorName)@,@arrStr[i]@


  return






// Status


var midhp = maxhp / 2
var lowhp = maxhp / 3
var hihp = (4 * maxhp) / 5




// FUNCTIONS






// Stats




/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getBuffLvl(nameid,inFoe)
// if inFoe = true, checks foe's buffs, else, player's buffs
  var lvl
  var buffFound
  var arrBuffs


  ?inFoe
    arrBuffs = string.Split(fbs,",", true)
  :
    arrBuffs = string.Split(bs,",", true)
    
  ?arrBuffs & !buffFound
    for buff : arrBuffs
      ?buff = nameid
        var arrInfo = string.Split(buff,":",true)


        lvl = int.Parse(arrInfo[2])
        buffFound = true


    ?buffFound = true
      return lvl
    :
      return 0


/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getDebuffLvl(nameid,inFoe)
// if inFoe = true, checks foe's debuffs, else, player's debuffs
  var lvl
  var debuffFound
  var arrDebuffs


  ?inFoe
    arrDebuffs = string.Split(fds,",", true)
  :
    arrDebuffs = string.Split(ds,",", true)


  ?arrDebuffs & !debuffFound
    for debuff : arrDebuffs
      ?debuff = nameid
        var arrInfo = string.Split(debuff,":",true)


        lvl = int.Parse(arrInfo[2])
        debuffFound = true


    ?debuffFound = true
      return lvl
    :
      return 0




func getFoeTotalHP()
  return fhp + fa




// Lost items




func canUseBlade()
  return tt >= bladeDelay


// cannot be interrupted, doesn't need a cooldown check
func useBlade()
  equip blade
  activate R


  bladeDelay = tt + bladeCd


  return


/* Checks if Blade of the Fallen God
can be used in 2 screens of distance,
according to a certain screen index. */
func canUseBladeDS(nScreen)
  return canUseBlade()
  ^& screen.i = nScreen


var slideCount = 0 // counter to give screen.Next() time to slide
func useBladeDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useBlade()
      screen.ResetOffset()
      return




func canUseArm()
  return tt >= armDelay &
  ^3 < fd & fd < 7


func useArm()
  equip arm
  activate R


  armDelay = tt + armCd


  return




func canUseMask()
  return tt >= maskDelay


func useMask()
  equipL triskelion
  equipR mask
  activate R


  maskDelay = tt + maskCd


  return




func canUseTali()
  return summon.count = 0 &
  ^tt >= taliDelay &
  ^canAct |
  ^(il = talisman & ils = 2) |
  ^(ir = talisman & irs = 2)


func canHideTali()
  return summon.count > 0 & summon.GetId() = "cinderwisp"
  ^& tt >= taliDelay
  ^& canAct |
  ^(il = talisman & ils = 2) |
  ^(ir = talisman & irs = 2)


func useTali(hand)
  ?hand = l
    equipL talisman
    activate L
  :?hand = r
    equipR talisman
    activate R


  taliDelay = tt + taliCd + castTime


  return


/* Checks if you can use the cinderwisp's "devour"
ability, and if the debuff level is >= to the requested. */
func canUseCind(nIgnitions)
  //equipR fire runestone


  return getDebuffLvl(ignition,true) >= nIgnitions &
  ^summon.count >= 1 & summon.GetId() = "cinderwisp"
  ^& tt >= cindDelay &
  ^canAct // & ir = fire runestone


func useCind()
  activate cinderwisp
  cindDelay = tt + cindCd + castTime
  return




/* Checks if you can use the
bashing shield's ability. */
func canBash()
  return tt >= bashDelay & !aiI
  ^& 11 <= fd & fd <= 15


func bash(lItem)
  equipL @lItem@
  equipR bashing shield


  bashDelay = tt + bashCd


  return








// Special Weapons




func canUseHamm()
  return tt >= hammDelay &
  ^canAct |
  ^(ir = heavy hammer &
  ^irs = 2)


func useHamm()
  equip heavy hammer
  activate R


  hammDelay = tt + hammCd + castTime


  return




func canUseBard()
  return tt >= bardDelay &
  ^canAct |
  ^(ir = bardiche &
  ^irs = 2)


func useBard()
  ?fd < 10
    equip bardiche
    activate R


    bardDelay = tt + bardCd + castTime


  return




/* Checks if you can use the
dashing shield's ability. */
func canDash()
  return tt >= dashDelay & !aiI
  ^& 11 <= fd & fd <= 15


func dash(lItem,yourDshield)
  equipL @lItem@
  equipR @yourDshield@


  dashDelay = tt + dashCd


  return




func canUseQstaff()
  ?tt >= qstaffDelay


    return canAct |
    ^(ir = quarterstaff
    ^& irs = 2)
  :
    return false


// recieves a string
func useQstaff(yourQuarterstaff)
  equip @yourQuarterstaff@
  activate R


  qstaffDelay = tt + qstaffCd


  return


func canUseMind()
  return item.GetCooldown("mind") <= 0








// Tools




func canUseHatchet()
  return item.GetCooldown("hatchet") <= 0
  ^& item.CanActivate("hatchet")
  ^& harvest.distance < 5
  ^& ir = hatchet


func useHatchet()
  activate R
  return








// Potions




/* Determines if a damage buff potion
is brewed. Generally used for bosses.
Potions related:
  - berserk
  - lucky */
func canUsePotDmg()
  return ip ! empty &
  ^(ip = berserk | ip = lucky)


/* Determines if a special potion
can be activated, given a special
condition that's different for each potion type.
Valid potion types and conditions:
  - cleansing | min. no. of debuffs to cleanse
  - strength | min. amount of foe's armor
  - lightning, | ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  - experience | min. no. of foes to activate
  - invisibility | NONE (will activate if foe = boss)
    + (send true as condition for this type) */
func canUsePotSpecial(type,cond)
  ?ip ! empty // potion hasn't been brewed or it's been used


    ?ip = type
      ?ip = cleansing
        return hp < midhp &
        ^debuffs.count >= cond
        // ^^^ = no. of debuffs to cleanse
    
      :?ip = strength
        return foe.armor & foe.armor > cond


      :?ip = lightning
      ^|ip = experience
        return foe.count >= cond


      :?ip = invisibility
        return f = boss


      :
        >c-10,0,#red,
        ^func canUsePotSpecial() - Potion recieved\n
        ^does not belong to this function: "@type@"
        return false


    :
      >c-10,0,#red,
      ^func canUsePotSpecial() - Potion recieved\n
      ^is not valid or equipped: "@type@"
      return false


  :
    return false








// Others




/* AAC = Attack Animation Cancelling
Cancels the attack animation of the
item after dealing damage with it.
NOTE: two-handed items count as right-handed. */
func canAAC(hand)
  ?ir = heavy hammer
  ^| ir = bardiche
  ^| ir = hatchet
  ^| il = hatchet
  ^| ir = hatchet
  ^| ir = shovel
    return false
  :
    ?hand = lh
      return ils = 3
    :?hand = rh
      return irs = 3


func useAAC(hand,junkItem)
  ?hand = lh
    equipL @junkItem@
    return
  :?hand = rh
    equipR @junkItem@
    return




func equipShield(shieldName)


  ?ir ! shieldName
    equipR @shieldName@
  :
    var fullArmor = maxarmor


    ?armor >= fullArmor
      return false
    :?armor < fullArmor / 2
      return true




// VARIABLES:




/* renamed:


Void Slayer = aether sword D *max
Speedy Hammer = stone hammer *max +10 */


//poison:
var psword1 = "poison sword dP *max"
var psword2 = "poison sword D *max +11"
var psword3 = "poison sword D *max +10"
var pSWORD = "big poison sword dP *max"
var pshield = "poison shield A *max"
var phammer1 = "poison hammer D *max +10"
var phammer2 = "poison hammer D *max +7"
var pbow = "poison bow D *max"
var pstaff = "poison staff dP *max"
//vigor:
var vsword1 = "vigor sword dL *max"
var vsword2 = "vigor sword D *max +10"
var vsword3 = "vigor sword D *max +7"
var vshield = "vigor shield A *max"
var vwand1 = "vigor wand D *max +9"
var vwand2 = "vigor wand D *max +3"
var vstaff = "vigor staff D *max"
//aether:
var aesword = "aether sword D *max"
// Void Slayer = aether sword D *max (2)
var aeSWORD1 = "big aether sword dU *max +10"
var aeSWORD2 = "big aether sword dU *max +9"
var aeshield1 = "aether shield -au *max"
var aeshield2 = "aether shield au *max"
var aebow = "aether crossbow D *max"
var aehammer1 = "aether hammer D *max +8"
var aehammer2 = "aether hammer D *max +7"
var aestaff = "aether staff dU *max"
//fire:
var fsword1 = "fire sword dF *max"
var fsword2 = "fire sword D *max +15"
var fsword3 = "fire sword D *max +10"
var fSWORD = "big fire sword dF *max"
var fshield = "fire shield A *max"
var fbow = "fire crossbow D *max"
var fstaff = "fire staff dF *9"
//ice:
var isword1 = "ice sword dI *max"
var isword2 = "ice sword D *max +12"
var isword3 = "ice sword D *max +10"
var ishield = "ice shield A *max"
var istaff = "ice staff dI *max"
//alternate:
var altsword1 = "stone sword *max +10"
var altsword2 = "stone sword *max +8"
var altbow = "crossbow *max"
var altshield = "stone shield *max"
//Speedy Hammer = stone hammer *max +10 (2)
var althammer1 = "stone hammer *max +11"
var althammer2 = "stone hammer *max +10"
//special weapons:
var dshield = "dashing shield *max"
var myqstaff = "quarterstaff golden"
var mybard = "bardiche *max"
var myhamm = "heavy hammer *max"
var cshield = "compound shield *max"
var rbow = "repeating crossbow *max"






// Weapons damage


var bladeDmg = 220
var bladeRDmg = 90
var smiteMult = 6.6 // mult = multiplier


var armDmg = 44
var armRDmg = armDmg / 2
var maxArmBuffs = 3


var taliRDmg = 80 // multiplied by the amount of Ignition buffs
var maxIgnitions = 10


var hammDmg = 109
//var hammerRDmg = 109 // (... ?)


var bardDmg = 52
var bardRDmg = bardDmg * 9








var tui = showTimeUI(13,1,pink)
var cdui = showCdownUI(1,1,orange)


?tt % 30 = 0
  tui = showTimeUI(13,1,pink)
?cdUpdate()
  cdui = showCdownUI(1,1,orange)




?l ! Halls & l ! Rocky
  ?hp < maxhp
    loc.Leave()


?l ! Mines
  ?loc.begin
    ?ip ! berserk
      brew wood + bronze // berserk potion
: // l = Mines
  ?loc.begin
    ?ip ! strength
      brew stone // strength potion






?l = Rocky
  // LOADOUTS


  func ldtF(mode)
    ?mode = Default
      equipL triskelion
      equipR @cshield@
    :?mode = escape
      equipL mind
      equipR @cshield@


      mindDelay = tt + mindCd
    :?mode = magnet
      equipL star
      equipR triskelion


    :?mode = harv
      equip shovel


    :?mode = aidPassive
      equipL ouroboros
      equipR triskelion
    :?mode = aidActive
      equipL @vsword1@
      equipR @cshield@


    //buffs/debuffs (oriented to damage)
    :?mode = pDeb
      equipL @psword1@
      equipR mask
    :?mode = vDeb | mode = aid
      equipL @vsword1@
      equipR mask
    //aether doesn't work on the foes here, so it doesn't count
    :?mode = fDeb
      equipL @fsword1@
      equipR mask
    :?mode = iDeb
      equipL @isword1@
      equipR mask
    //damage
    :?mode = pDmg
      equipL @psword2@
      equipR @psword3@
    :?mode = vDmg
      equipL @vsword2@
      equipR @vsword3@
    :?mode = aeDmg
      equipL Void Slayer
      equipR @aesword@
    :?mode = fDmg
      equipL @fsword2@
      equipR @fsword3@
    :?mode = iDmg
      equipL @isword2@
      equipR @isword3@


    //defense
    :?mode = pDef
      equipL @psword2@
      equipR @pshield@
    :?mode = vDef
      equipL @vsword2@
      equipR @vshield@
    :?mode = aeDef
      equipL Void Slayer
      equipR @aeshield1@
    :?mode = fDef
      equipL @fsword2@
      equipR @fshield@
    :?mode = iDef
      equipL @isword2@
      equipR @ishield@


    //armor-focused damage
    :?mode = pArmor
      equipL @phammer@
      equipR @phammer2@
    /*:?mode = vArmor
      equipL @vhammer1@
      equipR @vhammer2@*/
    :?mode = aeArmor
      equipL @aehammer1@
      equipR @aehammer2@
    /*:?mode = fArmor
      equipL @fhammer1@
      equipR @fhammer2@
    :?mode = iArmor
      equipL @ihammer1@
      equipR @ihammer2@*/
    :?mode = altArmor
      equipL @althammer1@
      equipR @althammer2@


    : // print error message on screen 
      >`0,0,#yellow,ERROR: ldtF() recieved incorrect mode.


    return




  // FUNCTIONS


  func harvFunc(btn)
    btnPressed = true
    ?btn = yesBtn
      choice = true
    : // btn = noBtn
      choice = false
    
    return


  func bossFight()


    ?canUseArm()
      ?bs = "pick_pocket:3"
        useArm()
      :
        equip arm
    :
      ?f = phase1
        ldtF(fDmg)


      :?f = phase2
        ?f = poison
          ldtF(iDmg)
        :?f = vigor
          ldtF(pDmg)
        :?f = aether
          ldtF(vDmg)
        :?f = fire
          ldtF(aeDmg)
        :?f = ice
          ldtF(fDmg)


      : // ?foe = phase3
        ft = foe.time


        ?(fs = 115 |
        ^(fs = 32 & fdmg = 1)) // putting up shield
        ^& ft >= 42
          dontDash = true


          ?canUseMind()
            ldtF(escape)
          :?fd > 7
            equip @rbow@
          :?canUseMask()
            useMask()
        :
          dontDash = false
          ?fa > 0
            ldtF(altArmor)
          :
            ?fbs = defense_poison
              ?fbs = defense_vigor
                ?fbs = defense_aether
                  ?fbs = defense_fire
                    ?fbs = defense_ice
                      equipL @altsword1@
                      equipR @altsword2@
                    :
                      ldtF(iDmg)
                  :
                    ldtF(fDmg)
                :
                  ldtF(aeDmg)
              :
                ldtF(vDmg)
            :
              ldtF(pDmg)


      ?php < pmhp
        equipR @vsword1@




    return




  // VARIABLES


  var dontDash




  // PROCEDURE




  var choice = false
  var btnPressed = false


  var yesBtn
  var noBtn


  var dontShowAgain = false




  ?!btnPressed
    ?!yesBtn
      yesBtn = makeButton(
      ^-5,9,4,4,null,null,
      ^"Yes",green,-5,harvFunc)
    ?!noBtn
      noBtn = makeButton(
      ^5,9,5,4,null,null,
      ^"No",red,-5,harvFunc)


    showStrCentered("Harvest boulders?",6,30,yellow)


  :
    ?yesBtn
      yesBtn.Recycle()
      yesBtn = null
    ?noBtn
      noBtn.Recycle()
      noBtn = null


    ?!dontShowAgain
      var aux = tt + 3*sec
      ?tt < aux
        ?choice
          showStrCentered("Harvest boulders is enabled",6,30,green)
        :
          showStrCentered("Harvest boulders is disabled",6,30,red)
      :
        ?!dontShowAgain
          dontShowAgain = true




  ?canUseTali()
    useTali(l)
  :?choice & harvest.distance < 5
    ldtF(harv)


  :?pickup.distance < 15
    ldtF(magnet)


  :
    fd = foe.distance
    php = hp
    pmhp = maxhp


    ?canUseQstaff() & !aiI
    ^& fd < 11 & 15 < fd
      useQstaff(myqstaff)
    
    ?fd > 15
      ldtF(default)
    
    :
      aiE = ai.enabled
      fs = foe.state


      ?aiE & fs ! -1 // fighting range


        f = foe
        fbs = foe.buffs.string
        fds = foe.debuffs.string


        fhp = foe.hp
        fa = foe.armor


        fdmg = foe.damage


        bs = buffs.string


        ?canUseBlade() & getFoeTotalHP() <= bladeRDmg
          useBlade()




        ?f = acronian_scout & fs ! 2
          ?canBash()
            bash(vsword1)
          :?canDash()
            dash(vsword1,dshield)


          :?canUseBard()
            useBard()
          :?canUseHamm()
            useHamm()


          :?fds = "debuff_chill:6"
            ?fds = debuff_damage
              ?fds = debuff_dot
                ?canUseArm()
                  ?bs = "pick_pocket:3"
                    useArm()
                  :
                    equip arm
                :
                  ?php = pmhp
                    ldtF(altArmor)
                  :
                    equipL @althammer1@
                    equipR @vsword1@
              :
                ldtF(fDeb)
            :
              ldtF(pDeb)
          :
            ldtF(iDeb)




        :?fs ! 124 &
        ^!(fs = 107 & fdmg = 3)
          // foe = Dysangelos


          ?canUseCind(10)
            useCind()


          ?canUsePotDmg() & f = phase3
            activate potion
      
          ?canBash() & !dontDash
            bash(vsword1)
          :?canDash() & !dontDash
            dash(vsword1,dshield)


          :?canUseBard()
            useBard()
          :?canUseHamm()
            useHamm()


          :?f ! immune_to_debuff_damage
          ^& fbs ! buff_protection
            ?fds = "debuff_chill:6"
              ?fds = debuff_damage
                ?fds = debuff_dot
                  bossFight()
                :
                  ldtF(fDeb)
              :
                ldtF(pDeb)
            :
              ldtF(iDeb)


          :
            bossFight()






:?l = Deadwood


  // FUNCTIONS


  func harvFunc(btn)
    btnPressed = true
    ?btn = yesBtn
      choice = true
    : // btn = noBtn
      choice = false
    
    return




  // VARIABLES




  var smiteScr = 1 // the screen we want the ds blade trick to be used on


  // LOADOUTS:


  func ldtF(mode)


    ?mode = default
      equipL triskelion
      equipR @cshield@
    :?mode = escape
      equipL mind
      equipR @cshield@
    :?mode = magnet
      equipL star
      equipR triskelion


    :?mode = harv
      equipL moon
      equipR hatchet


    :?mode = aidPassive
      equipL ouroboros
      equipR triskelion
    :?mode = aidActive
      equipL @vsword1@
      equipR @cshield@




    :?mode = meleeDmg
      equipL @vsword1@
      equipR @isword1@
    :?mode = meleeDef
      equipL @vsword1@
      equipR @cshield@
    :?mode = aoeDmg
      equipL @aeSWORD1@
      equipR @aeSWORD2@
    :?mode = aoeDef
      equipL @aeSWORD1@
      equipR @aeshield2@


    :?mode = poenaStun
      equipL @althammer1@
      equipR Speedy Hammer
    :?mode = poenaAid
      equipL @althammer1@
      equipR @vsword1@
    :?mode = poenaSword
      equipL @vsword1@
      equipR @psword2@


    :?mode = magicI
      equip @istaff@
    :?mode = magicP
      equip @pstaff@
    :?mode = magicF
      equip @fstaff@


    :?mode = rangedDmg
      equip @rbow@
    :?mode = rangedDef
      equipL @altbow@
      equipR @cshield@


    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@


    return




  // PROCEDURE:






  var choice = false
  var btnPressed = false


  var yesBtn
  var noBtn


  var dontShowAgain = false




  ?!btnPressed
    ?!yesBtn
      yesBtn = makeButton(
      ^-5,9,4,4,null,null,
      ^"Yes",green,-5,harvFunc)
    ?!noBtn
      noBtn = makeButton(
      ^5,9,5,4,null,null,
      ^"No",red,-5,harvFunc)


    showStrCentered("Harvest trees?",6,30,yellow)


  :
    ?yesBtn
      yesBtn.Recycle()
      yesBtn = null
    ?noBtn
      noBtn.Recycle()
      noBtn = null


    ?!dontShowAgain
      var aux = tt + 3*sec
      ?tt < aux
        ?choice
          showStrCentered("Harvest trees is enabled",6,30,green)
        :
          showStrCentered("Harvest trees is disabled",6,30,red)
      :
        ?!dontShowAgain
          dontShowAgain = true




  ?f ! poena & canUseTali()
    useTali(l)
  :?choice & harvest.distance < 5
    ldtF(harv)
    ?canUseHatchet()
      useHatchet()


  :?pickup.distance < 15
    ldtF(magnet)


  :
    fd = foe.distance


    ?item.right ! hatchet
    ^& canUseQstaff()
      useQstaff(myqstaff)


    ?canUseBladeDS(smiteScr)
      useBladeDS()


    ?(f ! tree_boss & f ! poena & fd > 22)
    ^|(fd > 15)
      ?hp = maxhp
        ldtF(default)
      :
        ldtF(aidPassive)


    :
      ?f = wasp | f = wasp_nest


        fds = foe.debuffs.string


        ?fd <= 10 & canUseHamm()
          useHammer()


        :?fds = "chill:6"
          ?fds = "dot"
            ?fds = "damage"
              ldtF(rangedDmg)
            :
              ldtF(magicP)
          :
            ldtF(magicF)
        :
          ldtF(magicI)


      :?canBash()
        bash(vsword1)
      :?canDash()
        dash(vsword1,dshield)


      :
        fc = foe.count


        ?f ! tree_boss & f ! poena


          ?fc >= 5 & !canUseBlade()
          ^& canUseHamm()
            useHamm()


          :?f ! immune_to_ranged
            ldtF(magicI)
          :
            pa = armor
            ?fc > 1
              ?pa > 15
                ldtF(aoeDmg)
              :
                ldtF(aoeDef)
            :
              ?pa > 15
                ldtF(meleeDmg)
              :
                ldtF(meleeDef)


        : // foe = tree_boss | foe = poena
          ls = loc.stars
          ft = foe.time


          >`0,10,#red,State: @foe.state@\n
          >`0,11,#yellow,Time: @ft@f (@ft/sec@ s)
          >`0,12,#magenta,Dist: @fd@\n
          >`0,13,#green,Count: @fc@


          ?ls <= 5
          ^ & canUseBard()
            useBard()


          :?ls > 5
            ?canUsePotDmg()
              activate potion


            ?f = phase1 // = Xyloalgia


              fds = foe.debuffs.string


              ?canUseCind(3)
                useCind()
              ?canUseMask()
                useMask()


              ?canUseBard()
                useBard()
              :?canUseHamm()
                useHamm()


              :?fds = "chill:6"
                ?fds = "dot"
                  ?fds = "damage"
                    ldtF(meleeDmg)


                  :
                    ldtF(magicP)
                :
                  ldtF(magicF)
              :
                ldtF(meleeDmg)


            : // foe = phase2 (poena)


              /* hide cinderwisp to avoid
              getting ignition debuff reflected */
              ?canHideTali()
                useTali(l)
              :
                fhp = foe.hp
                bs = buffs.string


                ?canUseBard() & fhp <= bardRDmg
                  useBard()
                :?canUseHamm() &
                ^fhp <= hammDmg + (smiteMult * getBuffLvl(smite,false))
                  useHamm()
                :
                  ldtF(poenaStun)






:?l = Caves
  // VARIABLES
  
  
  var smiteScr
  ?!smiteScr
    ?loc.stars <= 5
      smiteScr = 1
    :
      smiteScr = 2
  
  // LOADOUTS:
  
  func ldtF(mode)
  
    ?mode = default
      equipL triskelion
      equipR @cshield@
    :?mode = engage
      equipL triskelion
      equipR @ishield@
    :?mode = escape
      equipL mind
      equipR @ishield@
    :?mode = magnet
      equipL star
      equipR triskelion
  
    :?mode = aidPassive
      equipL ouroboros
      equipR @cshield@
    :?mode = aidActive
      equipL @isword2@
      equipR @vsword1@
  
  
    :?mode = meleeDmg
      equipL @isword2@
      equipR @isword3@
    :?mode = meleeDef
      equipL @isword2@
      equipR @ishield@
  
    :?mode = pDeb
      equipL @psword1@
      equipR mask
    :?mode = fDeb
      equipL @fsword1@
      equipR mask
  
    :?mode = magicDmg | mode = magicI
    ^| mode = magicDeb
      equip @istaff@
    :?mode = magicF
      equip @fstaff@
    :?mode = magicP
      equip @pstaff@
  
    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@
  
    return






  ?hp < maxhp
    loc.Leave()


  ?canUseTali()
    useTali(l)
  :?pickup.distance < 15
    ldtF(magnet)


  :
    fd = foe.distance


    ?canUseQstaff()
      useQstaff(myqstaff)


    ?canUseBladeDS(smiteScr)
      ?fd <= 33
        useBladeDS()


    ?fd > 35
      ldtF(default)


    :?fd > 15
      ldtF(engage) // equip rune shield and accumulate a lot of armor


    :
      fs = foe.state
      ft = foe.time


      ?(f = cool_bat &
      ^fs = 33 & ft > 27)
      ^|(f = spider_boss_harder
      ^& fs = 142 & ft > 57)
        ?canUseMind()
          ldtF(escape)
        :
          ?fd > 7
            ldtF(magicDmg)
          :
            ldtF(meleeDef)


      :?canBash()
        bash(isword2)
      :?canDash()
        dash(isword2,dshield)


      :
        fds = foe.debuffs.string


        ?f ! spider_boss_harder
          fc = foe.count


          ?fc >= 5
          ^& !canUseBlade()
          ^& canUseHamm()
            useHamm()


          :
            ?buffs.string = "smite"
              ?fds = "chill:6"
                ?fds = "damage"
                  ?fds = "dot"
                    ?armor > 15
                      ldtF(meleeDmg)
                    :
                      ldtF(meleeDef)
                  :
                    ldtF(magicF)
                :
                  ldtF(magicP)
              :
                ldtF(magicI)


            :
              ?fc = 1
                ldtF(meleeDmg)
              :
                ldtF(magicDmg)




          // foe = spider_boss
        :?fs ! 4 // dying
          ?canUseCind(10)
            useCind()
          ?canUsePotDmg()
            activate potion


          :?canUseMask()
            useMask()
          :?fd < 11
            ?canUseBard()
              useBard()
            :?canUseHamm()
              useHamm()


            :
              ?fds = "chill:6"
                ?fds = "damage"
                  ?fds = "dot"
                    ?fd < 7
                      ldtF(meleeDmg)
                    :
                      ldtF(magicDmg)
                  :
                    ldtF(magicF)
                :
                  ldtF(magicP)
              :
                ldtF(magicI)






:?l = Mushroom
  // VARIABLES
  
  
  var smiteScr
  ?!smiteScr
    ?loc.stars <= 5
      smiteScr = 1
    :
      smiteScr = 3
  
  // LOADOUTS:
  
  func ldtF(mode)
  
    ?mode = default
      equipL triskelion
      equipR @altshield@
    :?mode = engage
      equipL triskelion
      equipR @pshield@
    :?mode = escape
      equipL mind
      equipR @pshield@
    :?mode = magnet
      equipL star
      equipR triskelion
  
    :?mode = aidPassive
      equipL ouroboros
      equipR triskelion
    :?mode = aidActive
      equipL @psword2@
      equipR @vsword1@
  
  
    :?mode = meleeDeb
      equipL @psword1@
      equipR @psword2@
    :?mode = meleeDmg
      equipL @psword2@
      equipR @psword3@
    :?mode = meleeDef
      equipL @psword2@
      equipR @pshield@
  
    :?mode = armorDmg
      equipL @phammer1@
      equipR @phammer2@
    :?mode = armorDef
      equipL @phammer1@
      equipR @pshield@
  
    :?mode = rangedDmg
      equip @pbow@
      
    :?mode = magicP
      equip @pstaff@
    :?mode = magicI
      equip @istaff@
    :?mode = magicF
      equip @fstaff@
  
    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@
  
    return
  
  
  // PROCEDURE:




  ?hp < maxhp
    loc.Leave()




  ?canUseTali()
    useTali(l)
  :?pickup.distance < 15
    ldtF(magnet)


  :
    fds = foe.debuffs.string
    fd = foe.distance
    fc = foe.count


    ?f = explode


      ?fd < 10
      ^& canUseMind()
        ldtF(escape)
      :?fd <= 5
        ldtF(meleeDef)
      :


        ?fds = "chill:6"
          ?fds = "damage"
            ?fds = "dot"
              ldtF(rangedDmg)
            :
              ldtF(magicF)
          :
            ldtF(magicP)
        :
          ldtF(magicI)


    :
      ?canUseQstaff()
        useQstaff(myqstaff)


      ?fd > 35
        ldtF(default)




      :?fd > 15
        ldtF(engage) // equip rune shield and accumulate a lot of armor


      :?canBash()
        bash(psword2)
      :?canDash()
        dash(psword2,dshield)


      :?f ! mushroom_boss &
      ^f ! mushroom_boss_fat &
      ^f ! mushroom_boss_skinny
      
        ?canUseBladeDS(smiteScr)
          useBladeDS()


        :
          ?fc >= 5
          ^&canUseHamm()
            useHamm()
            
          :?buffs.string = "smite"


            ?fds = "chill:6"
            
              ?armor > 15
                ?fa > 0
                  ldtF(armorDmg)
                :
                  ldtF(meleeDmg)
              :
                ?fa > 0
                  ldtF(armorDef)
                :
                  ldtF(meleeDef)


            :
              ldtF(magicI)


          :
            ?fc = 1
              ?fa > 0
                ldtF(armorDmg)
              :
                ldtF(meleeDmg)
            :
              equipL @aeSWORD1@
              equipR @aeSWORD2@




      : // foe = mushroom_boss(es)
        fs = foe.state


        ?fs ! 1 // boss appearing animation
        ^&fs ! 4 // dying


          ?canUseCind(10)
            useCind()
          ?canUsePotDmg()
            activate potion


          :?canUseHamm()
            useHamm()
          :?canUseBard()
            useBard()


          :?f = phase2 & canUseMask()
            useMask()


          :?fs = 32 & foe.time >= 2*sec // boss's punch attack
          ^& canUseMind()
            ldtF(escape)


          ://?!canUseHamm() & !canUseBard()
            ?fds = "chill:6"
              ?fds = "damage"
                ?fds = "dot"
                  ?fa > 0
                    ldtF(armorDmg)
                  :
                    ldtF(meleeDmg)
                :
                  equipL @psword2@
                  equipR @fSWORD@
              :
                ldtF(meleeDeb)
            :
              ldtF(magicI)






:?l = Halls
  // VARIABLES
  
  
  var smiteScr
  ?!smiteScr
    ?loc.stars <= 5
      smiteScr = 1
    :
      smiteScr = 1
  :?loc.loop & smiteScr = 1
    smiteScr = 4
  
  
  // LOADOUTS:
  
  func ldtF(mode)
  
    ?mode = default
      equipL triskelion
      equipR @cshield@
    :?mode = engage
      equipL triskelion
      equipR @vshield@
    :?mode = escape
      equipL mind
      equipR @ishield@
    :?mode = magnet
      equipL star
      equipR triskelion
  
    :?mode = aidPassive
      equipL ouroboros
      equipR triskelion
    :?mode = aidActive
      equipL @vsword1@
      equipR @vwand1@
  
  
    :?mode = meleeDmg
      equipL @vsword2@
      equipR @vsword3@
  
    :?mode = magicDmg
      equipL @vwand1@
      equipR @vwand2@
    :?mode = magicI
      equip @istaff@
  
    :?mode = iDeb
      equipL @vsword1@
      equipR @isword1@
    :?mode = pDeb
      equipL @vsword1@
      equipR @psword1@
    :?mode = fDeb
      equipL @vsword1@
      equipR @fsword1@
  
    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@
    return
  
  
  // PROCEDURE:


  ?canUseTali()
    useTali(l)
  :?pickup.distance < 15
    ldtF(magnet)


  :
    fd = foe.distance


    ?canUseQstaff()
      useQstaff(myqstaff)


    ?canUseBladeDS(smiteScr)
      ?fd <= 33
        useBladeDS()


    ?fd > 35
      ldtF(default)
    :?fd > 15
      ldtF(engage) // equip rune shield and accumulate a lot of armor
    
    :?canBash()
      bash(vsword1)
    :?canDash()
      dash(vsword1,dshield)


    :
      fc = foe.count


      ?fc >= 5 & canUseHamm()
        useHamm()


      :?foe.name = "R.I.Pieces"
        fds = foe.debuffs.string
        ?fds = "chill:6"
          ?fds = "damage"
            ?fds = "dot"
              ldtF(meleeDmg)
            :
              ldtF(fDeb)
          :
            ldtF(pDeb)
        :
          ldtF(iDeb)


      :?f ! pallas
        ldtF(magicI)


      : // f = pallas
        fs = foe.state
        ?fs ! 100 & fs ! 4
          // 100 = entering 2nd phase, 4 = dying
          fds = foe.debuffs.string
          ?canUseCind(10)
            useCind()


          ?f = phase2 & fs = 32 &
          ^foe.time / sec >= 1 &
          ^(canUseMask() | canUseHamm())
            // 32 = about to attack
            ?canUseMask()
              useMask()
            :?canUseHamm()
              useHamm()


          :
            ?canUseBard()
              useBard()
            :
              ?canUsePotDmg()
                activate potion
              :
                fds = foe.debuffs.string
                ?fds = "chill:6"
                  ?fds = "damage"
                    ?fds = "dot"
                      ldtF(meleeDmg)
                    :
                      ldtF(fDeb)
                  :
                    ldtF(pDeb)
                :
                  ldtF(iDeb)






:?l = Mine
  // VARIABLES
  
  
  var smiteScr
  ?!smiteScr
    ?loc.stars <= 5
      smiteScr = 1
    :
      smiteScr = 1
  :?loc.loop & smiteScr = 1 & loc.stars > 5
    smiteScr = 3
  
  // LOADOUTS:
  
  func ldtF(mode)
  
    ?mode = default
      equipL triskelion
      equipR @cshield@
    :?mode = escape
      equipL mind
      equipR @aeshield1@
    :?mode = magnet
      equipL star
      equipR triskelion
  
    :?mode = aidPassive
      equipL ouroboros
      equipR triskelion
    :?mode = aidActive
      equipL Void Slayer
      equipR @vsword1@
  
  
    :?mode = engArmor
      equipL triskelion
      equipR @aeshield1@
    :?mode = engUnmk
      equipL triskelion
      equipR @aeshield2@
  
    :?mode = meleeDmg
      equipL Void Slayer
      equipR @aesword@
    :?mode = meleeAOE
      equipL @aeSWORD1@
      equipR @aeSWORD2@
    :?mode = meleeDef
      equipL @aeSWORD1@
      equipR @aeshield2@
  
    :?mode = fDeb
      equipL Void Slayer
      equipR @fsword1@
    :?mode = pDeb
      equipL Void Slayer
      equipR @psword1@
  
  
    :?mode = hammerDmg
      equipL @aehammer1@
      equipR @aehammer2@
    :?mode = hammerDef
      equipL @aehammer1@
      equipR @aeshield2@
  
    :?mode = rangedDmg
      equip @aebow@
  
    :?mode = magicI
      equip @istaff@
    :?mode = magicF
      equip @fstaff@
    :?mode = magicP
      equip @pstaff@
  
    :
      >`0,2,#red,ERROR: ldtF() recieved incorrect mode
    return
  
  
  // PROCEDURE:




  /*?loc.begin
    ?ip ! strength
      brew stone // strength potion*/


  ?canUseTali()
    useTali(l)
  :?pickup.distance < 15
    ldtF(magnet)


  :
    fd = foe.distance


    ?canUseBladeDS(smiteScr)
      ?fd <= 33


        useBladeDS()


    ?canUseQstaff() & f ! explode
      useQstaff(myqstaff)
    ?fd > 35
      ldtF(default)
    :
      fds = foe.debuffs.string


      ?f ! bronze_guardian
        ?fd > 15
          ldtF(engArmor) // equip rune shield and accumulate a lot of armor
        :?canBash()
          bash(Void Slayer)
        :?canDash()
          dash(Void Slayer,dshield)


        :?f = explode // the miniboss - it should've already dashed
          ldtF(escape) // so we should instantly escape from explosion with mindstone
        :
          ?foe.count >= 5
          ^& !canUseBlade()
          ^& canUseHamm()
            useHamm()
          :
            ?fds = "chill:6"
              ?fds = "damage"
                ?fds = "dot"
                  ?fd < 7
                    ?armor > 15
                      ldtF(meleeAOE)
                    :
                      ?foe.armor > 0
                        ldtF(hammerDef)
                      :
                        ldtF(meleeDef)
                :
                  ldtF(magicF)
              :
                ldtF(magicP)
            :
              ldtF(magicI)




      : // f = bronze_guardian
        fs = foe.state
        ft = foe.time


        ?fs ! 1 // boss appearing cinematic
        ^&fs ! 4 // dying


          ?canUseCind(8)
            useCind()


          ?fs = 32


            ?ft >= sec // boss's hammer attack
              ldtF(escape) // ranged with shield
            :
              ldtF(rangedDmg)


          :?canUsePotDmg() |
          ^canUsePotSpecial(strength,0)
            activate potion
          :?canUseMask()
            useMask()
          :?canUseHamm()
            useHamm()


          :?fs = 33 & ft < 6*sec // boss's hammer's stuck


            ?ft > 5 & canUseQstaff()
              useQstaff(myqstaff)


            :?fd > 15
              equipL triskelion // get close fast to boss
              equipR Void Slayer
            :?canBash()
              bash(Void Slayer)
            :?canDash()
              dash(VoidSlayer,dshield)


            :
              ?canUseBard()
                useBard()
              :
                ?foe.armor > 0
                  ldtF(hammerDmg)


                :
                  ?fds = "dot"
                    ?fds = "damage"
                      ldtF(meleeDmg)
                    :
                      ldtF(pDeb)
                  :
                    ldtF(fDeb)


          :
            ?fds = "damage"
              ?fds = "dot"
                ldtF(rangedDmg)
              :
                ldtF(magicF)
            :
              ldtF(magicP)






?l = Ridge


  // VARIABLES




  var smiteScr = 1
  var blowing


  // LOADOUTS:


  func ldtF(mode)


    ?mode = default
      equipL triskelion
      equipR @cshield@
    :?mode = engage
      equipL triskelion
      equipR @fshield@
    :?mode = escape
      equipL mind
      equipR @fshield@
    :?mode = magnet
      equipL star
      equipR triskelion


    :?mode = aidPassive
      equipL ouroboros
      equipR triskelion
    :?mode = aidActive
      equipL @fsword1@
      equipR @vsword1@


    :?mode = rangedDmg
      equip @fbow@


    :?mode = magicI
      equip @istaff@
    :?mode = magicP
      equip @pstaff@
    :?mode = magicF
      equip @fstaff@


    :?mode = meleeDmg
      equipL @fsword2@
      equipR @fsword3@
    :?mode = meleeDef1
      equipL @fSWORD@
      equipR @fshield@
    :?mode = meleeDef2
      equipL @fsword2@
      equipR @fshield@


    :?mode = fDeb
      equipL @fsword2@
      equipR @fsword1@
    :?mode = iDeb
      equipL @fsword2@
      equipR @isword1@
    :?mode = pDeb
      equipL @fsword2@
      equipR @psword1@


    :?mode = AOEDeb
      equipL @fsword2@
      equipR @fSWORD@


    :?mode = unmkDmg
      equipL @aeSWORD1@
      equipR @aeSWORD2@
    :?mode = unmkDef
      equipL @aeSWORD1@
      equipR @aeshield2@


    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@
    return




  // PROCEDURE:
  
  ?canUseTali()
    useTali(l)


  :?pickup.distance < 15
    ldtF(magnet)


  :
    fd = foe.distance
    fs = foe.state


    ?canUseBladeDS(smiteScr)
      ?fd <= 33
        useBladeDS()


    ?f ! yeti
      ?canUseQstaff()
        useQstaff(myqstaff)
      :?fd > 35
        ldtF(default)
      :?fd > 15
        ldtF(engage)
      :?canBash()
        bash(isword2)
      :?canDash()
        dash(isword2,dshield)


      :
        fc = foe.count
        fn = foe.name


        ?canUseHamm() & screen.i = 3
          useHamm()


        :?f = spawner | fn = "Ice Wall"
          ?fd <= 6
            ldtF(unmkDmg)
          :
            ldtF(unmkDef)
        :
          ?fn = "Giant Ice Elemental" // the miniboss
            ?fs = 32 | fs = 33 // attacking
              ldtF(meleeDef2)
            :
              bs = buffs.string
              ?getBuffLvl(smite,false) < 7
                ldtF(meleeDmg)
              :
                fds = foe.debuffs.string
                ?fds ! "damage"
                  ldtF(pDeb)
                :
                  ?fds ! "dot"
                    ldtF(fDeb)
                  :
                    ldtF(rangedDmg)
          :
            ?f = ice_elemental | f = ice_elemental_elite
              ?armor < 10
                ldtF(meleeDef1)
              :?fc > 1
                ldtF(magicI)
              :
                ldtF(meleeDmg)
            :
              ?fc = 1
                ldtF(meleeDmg)
              :
                bs = buffs.string
                ?getBuffLvl(smite,false) < 7
                  ?fd <= 6
                    ldtF(unmkDmg)
                  :
                    ldtF(unmkDef)
                :
                  fds = foe.debuffs.string
                  ?fds ! "chill:6"
                    ldtF(magicI)
                  :
                    ?fds ! "damage"
                      ldtF(magicP)
                    :
                      ?fds ! "dot"
                        ldtF(meleeDef1)
                      :
                        ?fd <= 6
                          ldtF(unmkDmg)
                        :
                          ldtF(unmkDef)




    : // foe = yeti
      ?foe.armor <= 0 & (canUseMask() | canUseBard())
        ?canUseMask()
          useMask()
        :?canUseBard()
          useBard()
      :?fd > 35 | fs = 1 | fs = 4
        ?canUseQstaff()
          useQstaff(myqstaff)
        :
          ldtF(default)
      :?foe.hp <= 120 &
      ^(canBash() | canDash())
        ?canBash()
          bash(fsword1)
        :?canDash()
          dash(fsword1,dshield)
      :
        fds = foe.debuffs.string


        ?(fs = 133 | fs = 143)
        ^ & foe.time/sec <= 3
          blowing = true
        :
          blowing = false


        ?blowing
          bs = buffs.string
          ?canUseCind(6)
            useCind()


          ?fds ! "chill:6"
            ldtF(magicI)
          :
            ?fds ! "dot"
              ldtF(magicF)
            :
              ldtF(rangedDmg)
        : // not blowing
          ?fd > 15 & fs ! 0
            ldtF(engage) // equip rune shield and accumulate a lot of armor
          ?canBash()
            bash(fsword1)
          :?canDash()
            dash(fsword1,dshield)


          :
            ?fs = 0
              ?canUseHamm()
                useHamm()
              :
                equipL @althammer1@
                equipR @althammer2@
            :
              ?canUsePotDmg()
                activate potion
              :
                ?fds ! "chill:6"
                  ldtF(iDeb)
                :
                  ?fds ! "dot"
                    ldtF(fDeb)
                  :
                    ldtF(meleeDmg)


  ?canAAC(lh)
    useAAC(lh,altsword1)
  ?canAAC(rh)
    useAAC(rh,altshield)






//:?l = Temple








:?l = Gate
  import Cosmetics/PetFrog


  ?aiI
    equipL @vsword1@
  :
    equipL triskelion
  equipR mask


  var freeChest = import UI/FreeChestTracker
  freeChest.Main()






?canAAC(lh)
  useAAC(lh,altsword1)
?canAAC(rh)
  useAAC(rh,altshield)