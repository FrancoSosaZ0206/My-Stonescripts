// import Cosmetics/PetBoo
import Cosmetics/PetStonehead

var mind = import UI/MindstoneButton
mind.SetXY(1,13)

// *******************************************************
//                       FILE INFO
// *******************************************************

// Script for Icy Ridge

//IMPORTS

// *******************************************************
//                     utilities.txt                      
// *******************************************************

// VARIABLES:

//Units

var sec = 30 // frames
var scr = 69 // 1 screen = 69 units

//FUNCTIONS:

func myFormatDigital(frames)
  ?frames <= 0
    return "00:00"
  :
    var timeStr
    var secs
    var mins
    var secStr
    var minStr

    secs = frames/30
    mins = (frames/30)/60

    secs -= mins*60

    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins
      
    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
    
    return minStr + ":" + secStr


// *******************************************************
//                 END OF "utilities.txt"                 
// *******************************************************

// *******************************************************
//                    performanceV2.txt                   
// *******************************************************


// VARIABLES - definitions


//Location
var l = loc
var ls = loc.stars
var lavg = loc.averageTime
var lbt = loc.bestTime
var lb
var ll


// Foe
var f
f = foe
var fn
var fbs
var fds
var fd
var fc
var fs
var ft
var fhp
fhp = foe.hp
var fa
fa = foe.armor
var fdmg

// Time
var tt
tt = totaltime

// Item
var ip
ip = item.potion
var il
il = item.left
var ils
ils = item.left.state
var ilt
var ili

var ir
ir = item.right
var irs
irs = item.right.state
var irt
var iri

// Player stats
var php
var pmhp
var pa
var pma
var ds
var bs

// Ai
var aiE
var aiI
aiI = ai.idle


//screen
var si
si = screen.i


// Functions
var canAct
canAct = item.CanActivate()

// Cooldowns
var bladeCd = 80 * sec
var maskCd = 48 * sec
var armCd = 39 * sec
var fTaliCd = 5 * sec
var aeTaliCd = 5 * sec
var cindCd = 90 * sec
var weaverCd = 90 * sec

var bardCd = 30 * sec
var hammCd = 22 * sec
var mindCd = 12 * sec // currently not in use
var qstaffCd = 5 * sec + 15 // 5,5s
var dashCd = sec + 15 // 1,5s
var bashCd = 9 * sec

// Cast times
var castTime = sec

// Delays
var bladeDelay = 0
var maskDelay = 0
var armDelay = 0
var fTaliDelay = 0
var aeTaliDelay = 0
var cindDelay = 0
var weaverDelay = 0

var bardDelay = 0
var hammDelay = 0
var mindDelay = 0 // currently not in use
var qstaffDelay = 0
var dashDelay = 0
var bashDelay = 0

?tt < 3
  lb = loc.begin
  ll = loc.loop
?tt = 1
  lavg = loc.averageTime
  lbt = loc.bestTime
  
  bladeDelay = 0
  maskDelay = 0
  armDelay = 0
  fTaliDelay = 0
  aeTaliDelay = 0
  cindDelay = 0
  weaverDelay = 0

  bardDelay = 0
  hammDelay = 0
  mindDelay = 0 // currently not in use
  qstaffDelay = 0
  dashDelay = 0
  bashDelay = 0

// *******************************************************
//               END OF "performanceV2.txt"               
// *******************************************************

// *******************************************************
//                    MyBetterInfo.txt                    
// *******************************************************

// FUNCTIONS



/* supports only basic colors.
Default color names from the game
(e. red, rainbow, cyan, etc.)
are also accepted. */
func colorToHex(colorName)
  ?colorName = red
    return #FF0000
  :?colorName = orange
    return #FF7518
  :?colorName = yellow
    return #FFFF00
  :?colorName = gold
    return #E49B0F
  :?colorName = blue
    return #0000FF
  :?colorName = cyan
    return #00FFFF
  :?colorName = magenta
    return #FF00FF
  :?colorName = pink
    return #E0115F
  :?colorName = purple
    return #800080
  :?colorName = violet
    return #7F00FF
  :?colorName = green
    return #008000
  :?colorName = darkGreen
    return #023020
  :?colorName = white
    return #FFFFFF
  :?colorName = gray
    return #808080
  :?colorName = black
    return #000000
  :?colorName = brown
    return #7B3F00
  :?colorName = turquoise | colorName = turquesa
    return #40E0D0
  :?colorName = rainbow | colorName = rgb
    return #rainbow
  :
    >c-20,0,#red,ERROR: colorToHex() got unexisting color: @colorName@


func makeTextbox(x,y,w,h,txtStr,colorName,styleID)

  //declarations:
  var panel
  var txt

  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(txtStr)


  //adding style and text to the panel:
  panel.style = styleID
  panel.Add(txt)

  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left

  //adding color
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)

  //adding position
  panel.x = x
  panel.y = y

  txt.x = 1
  txt.y = 1

  //adding wide and height
  panel.w = txt.w + w
  panel.h = txt.h + h

  return panel

func makeButton(x,y,w,h,anchor,dock,txtStr,colorName,styleID,actionFunc)
  var btn

  btn = ui.AddButton()

  btn.x = x
  btn.y = y

  btn.text = txtStr

  btn.w = string.Size(btn.text) + w
  btn.h = h

  ?anchor
    btn.anchor = anchor
  ?dock
    btn.dock = dock


  ?styleID
    btn.style = styleID

  ?colorName
    var colorID = colorToHex(colorName)
    btn.tcolor = colorID
    btn.bcolor = colorID
    btn.hcolor = colorID
  
  btn.SetPressed(actionFunc)

  return btn


var bardTime
var hammTime
var mindTime
var stafTime
var dashTime
var bashTime

bardTime = myFormatDigital(bardDelay-tt)
hammTime = myFormatDigital(hammDelay-tt)
mindTime = myFormatDigital(mindDelay-tt)
stafTime = myFormatDigital(qstaffDelay-tt)
bashTime = myFormatDigital(bashDelay-tt)
dashTime = myFormatDigital(dashDelay-tt)

var bardTime_old
var hammTime_old
var mindTime_old
var stafTime_old
var bashTime_old
var dashTime_old

func cdUpdate()
  //if ANY cooldown changed,
  ?bardTime_old ! bardTime |
  ^hammTime_old ! hammTime |
  ^mindTime_old ! mindTime |
  ^stafTime_old ! stafTime |
  ^bashTime_old ! bashTime |
  ^dashTime_old ! dashTime
    // we update the _old variables
    bardTime_old = bardTime
    hammTime_old = hammTime
    mindTime_old = mindTime
    stafTime_old = stafTime
    bashTime_old = bashTime
    dashTime_old = dashTime
    // and return true
    return true
  : // else, we return false
    return false

func showCdownUI(x,y,colorName)

  //declarations:
  var panel
  var txt

  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(
  ^     "BARD " + bardTime
  ^ + "\nHAMM " + hammTime
  ^ + "\nMIND " + mindTime
  ^ + "\nSTAF " + stafTime
  ^ + "\nBASH " + bashTime
  ^ + "\nDASH " + dashTime )


  //adding style and text to the panel:
  panel.style = 1
  panel.Add(txt)

  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left

  //adding color
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)

  //adding position
  panel.x = x
  panel.y = y

  txt.x = 1
  txt.y = 1

  //adding wide and height

  txt.w = 10

  panel.w = txt.w + 2
  panel.h = txt.h + 3

  return panel


func showBigStrUI(str,maxwidth,x,y,colorID)

  //declarations:
  var panel
  var txt

  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(str)


  //adding style and text to the panel:
  panel.style = -1
  panel.Add(txt)

  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left

  //adding color
  ?colorID
    txt.color = colorToHex(colorID)
    panel.color = colorToHex(colorID)

  //adding position
  panel.x = x
  panel.y = y

  txt.x = 1
  txt.y = 1

  txt.w = maxwidth

  //adding wide and height
  panel.w = txt.w + 2
  panel.h = txt.h + 2

  return panel


func showStrCentered(str,y,maxW,colorName)
  ?string.Size(str) <= maxW
    >c@-(string.Size(str)-1)/2@,@y@,@colorToHex(colorName)@,@str@
  :
    var arrStr = string.Break(str,maxW)
    ?arrStr
      for i = 0 .. arrStr.Count() - 1
        >c@-(string.Size(str)-1)/2@,@y-((arrStr.Count()-1))/2+i@,@colorToHex(colorName)@,@arrStr[i]@

  return

// *******************************************************
//               END OF "MyBetterInfo.txt"                
// *******************************************************

// *******************************************************
//                       Combat.txt                       
// *******************************************************

// VARIABLES


// Status

var midhp = maxhp / 2
var lowhp = maxhp / 3
var hihp = (4 * maxhp) / 5


// FUNCTIONS



// Stats


/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getBuffInfo(nameid,inFoe,infoIndex)
// if inFoe = true, checks foe's buffs, else, player's buffs
  var info
  var buffFound
  var arrBuffs

  ?inFoe
    arrBuffs = string.Split(fbs,",", true)
  :
    arrBuffs = string.Split(bs,",", true)
    
  ?arrBuffs & !buffFound
    for buff : arrBuffs
      ?buff = nameid
        var arrInfo = string.Split(buff,":",true)

        ?0 <= infoIndex & infoIndex <= 3
          info = int.Parse(arrInfo[infoIndex])

        buffFound = true

    ?buffFound = true
      return info
    :
      return 0

/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getDebuffLvl(nameid,inFoe)
// if inFoe = true, checks foe's debuffs, else, player's debuffs
  var lvl
  var debuffFound
  var arrDebuffs

  ?inFoe
    arrDebuffs = string.Split(fds,",", true)
  :
    arrDebuffs = string.Split(ds,",", true)

  ?arrDebuffs & !debuffFound
    for debuff : arrDebuffs
      ?debuff = nameid
        var arrInfo = string.Split(debuff,":",true)

        lvl = int.Parse(arrInfo[2])
        debuffFound = true

    ?debuffFound = true
      return lvl
    :
      return 0


func getFoeTotalHP()
  return fhp + fa



// Lost items


func canUseBlade()
  return tt >= bladeDelay & canAct

// cannot be interrupted, doesn't need a cooldown check
func useBlade()
  equip blade
  activate R

  bladeDelay = tt + bladeCd

  return

/* Checks if Blade of the Fallen God
can be used in 2 screens of distance,
according to a certain screen index. */
func canUseBladeDS(nScreen)
  return canUseBlade()
  ^& si = nScreen

var slideCount = 0 // counter to give screen.Next() time to slide
func useBladeDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useBlade()
      screen.ResetOffset()
      return


func canUseArm()
  return tt >= armDelay &
  ^3 < fd & fd < 7
  ^& canAct

func useArm()
  equip arm
  activate R

  armDelay = tt + armCd

  return


func canUseMask()
  return tt >= maskDelay & canAct

func useMask()
  equipL triskelion
  equipR mask
  activate R

  maskDelay = tt + maskCd

  return

func canUseMaskDS(nScreen)
  return canUseMask()
  ^& si = nScreen

func useMaskDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useMask()
      screen.ResetOffset()
      return


func canUseFTali()
  return
  ^summon.GetId() ! "cinderwisp" &
  ^tt >= fTaliDelay &
  ^canAct |
  ^(il = "fire_talisman" & ils = 2) |
  ^(ir = "fire_talisman" & irs = 2)

func useFTali(hand)
  ?hand = "l"
    equipL fire_talisman
    activate L
  :?hand = "r"
    equipR fire_talisman
    activate R

  fTaliDelay = tt + fTaliCd + castTime

  return

/* Checks if you can use the cinderwisp's "devour"
ability. */
func canUseCind()
  return summon.count >= 1
  ^& summon.GetId() = "cinderwisp"
  ^& tt >= cindDelay & canAct

/* Checks if the estimated damage of
cinderwisp's "devour" ability will kill the foe,
leaving a damage margin.
  - cindDmg: represents the damage the cinderwisp does,
             which will be multiplied by each ignition
             debuff applied.
  - margin: number representing a health margin to add
            to the remaining foe's health. This is
            necessary because the ability has a cast time
            that will alter the estimations done here.
            Send 0 if you don't want to use a margin. */
func canKillCind(cindDmg,margin)
  return getFoeTotalHP() <= (getDebuffLvl(ignition,true) * cindDmg) + margin

func useCind()
  activate cinderwisp
  cindDelay = tt + cindCd + castTime
  return


func canUseAETali()
  return
  ^summon.GetId() ! "voidweaver" &
  ^tt >= aeTaliDelay &
  ^canAct |
  ^(il = "aether_talisman" & ils = 2) |
  ^(ir = "aether_talisman" & irs = 2)

func useAETali(hand)
  ?hand = "l"
    equipL aether_talisman
    activate L
  :?hand = "r"
    equipR aether_talisman
    activate R

  aeTaliDelay = tt + aeTaliCd + castTime

  return

/* Checks if you can use the voidweaver's "devour"
ability. */
func canUseWeaver()
  return summon.count >= 1
  ^& summon.GetId() = "voidweaver"
  ^& tt >= weaverDelay & canAct

func useWeaver()
  activate voidweaver
  weaverDelay = tt + weaverCd + castTime
  return

func canUseWeaverDS(nScreen)
  return canUseWeaver()
  ^& si = nScreen

func useWeaverDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20

  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useWeaver()
      screen.ResetOffset()

      return


/* Checks if you can use the
bashing shield's ability. */
func canBash()
  return tt >= bashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct

func bash(lItem)
  equipL @lItem@
  equipR bashing shield

  bashDelay = tt + bashCd

  return




// Special Weapons


func canUseHamm()
  return tt >= hammDelay &
  ^canAct |
  ^(ir = heavy hammer &
  ^irs = 2)

func useHamm()
  equip heavy hammer
  activate R

  hammDelay = tt + hammCd + castTime

  return


func canUseBard()
  return tt >= bardDelay &
  ^canAct |
  ^(ir = bardiche &
  ^irs = 2)

func useBard(yourBard)
  ?fd < 10
    equip @yourBard@
    activate R

    bardDelay = tt + bardCd + castTime

  return


/* Checks if you can use the
dashing shield's ability. */
func canDash()
  return tt >= dashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct

func dash(lItem,yourDshield)
  equipL @lItem@
  equipR @yourDshield@

  dashDelay = tt + dashCd

  return


func canUseQstaff()
  ?tt >= qstaffDelay

    return canAct |
    ^(ir = quarterstaff
    ^& irs = 2)
  :
    return false

// recieves a string
func useQstaff(yourQuarterstaff)
  equip @yourQuarterstaff@
  activate R

  qstaffDelay = tt + qstaffCd

  return

func canUseMind()
  return item.GetCooldown("mind") <= 0 & canAct


// Potions


func canUsePot()
  return ip ! empty & canAct


/* Determines if a damage buff potion
is brewed. Generally used for bosses.
Potions related:
  - berserk
  - lucky */
func canUsePotDmg()
  return canUsePot() &
  ^(ip = berserk | ip = lucky)

/* Determines if a special potion
can be activated, given a special
condition that's different for each potion type.
Valid potion types and conditions:
  - cleansing | min. no. of debuffs to cleanse
  - strength | min. amount of foe's armor
  - lightning, | ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  - experience | min. no. of foes to activate
  - invisibility | NONE (will activate if foe = boss)
    + (send true as condition for this type) */
func canUsePotSpecial(type,cond)
  ?canUsePot()

    ?ip = type
      ?ip = cleansing
        return hp < midhp &
        ^debuffs.count >= cond
        // ^^^ = no. of debuffs to cleanse
    
      :?ip = strength
        return foe.armor & foe.armor > cond

      :?ip = lightning
      ^|ip = experience
        return foe.count >= cond

      :?ip = invisibility
        return f = boss

      :
        >c-10,0,#red,
        ^func canUsePotSpecial() - Potion recieved\n
        ^does not belong to this function: "@type@"
        return false

    :
      >c-10,0,#red,
      ^func canUsePotSpecial() - Potion recieved\n
      ^is not valid or equipped: "@type@"
      return false

  : // potion hasn't been brewed, it's been used,
    return false //or just can't be activated atm




// Others

var moonTimer = 0
var moonFrame
func doMoondial(weapon1, weapon2, mode)
  ?mode = 0 // Normal moondialing
    moonTimer++
    moonFrame = moonTimer % 3

    ?moonFrame = 1
      equipL moon
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?mode = 1 // Berserk Moondialing (For non-speed enchanted *max swords)
    moonTimer++
    moonFrame = moonTimer % 4

    ?moonFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon1@
    :?moonFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moonFrame = 4
      equipL moon
      equipR @weapon2@
  
  :?mode = 2 // Not moondialing, but useful to have here (speed enchant *max swords)
    equipL @weapon2@
    equipR @weapon1@


  return

// *******************************************************
//                  END OF "Combat.txt"                   
// *******************************************************

// *******************************************************
//                     MyArsenal.txt                      
// *******************************************************

// VARIABLES:


/* renamed:

Mamba Negra = poison sword D *max
Dothaneel = vigor sword D *max
Void Slayer = aether sword D *max
Vantum Phoenix = fire sword D *max
Bifrost = ice sword D *max
Glaciar = big ice sword dI *max
Speedy Hammer = stone hammer *max
Kubikiribocho = bardiche *max (enchanted: crit) */

//poison:
var dPsword1 = "poison sword dP *max +13" // enchanted: speed
var dPsword2 = "poison sword dP +0" // enchanted: debuff
var psword = "poison sword D *max"
var pshield = "poison shield A *max"
var pbow = "poison bow -dP *max"
var dPbow = "poison bow dP *max"
var dPwand = "poison wand dP *max"
//vigor:
var dLsword = "vigor sword dL *max"
var vsword = "vigor sword D *max"
var vshield = "vigor shield A *max"
var ahShield = "vigor shield ah *max"
var ahHammer = "vigor hammer ah *max"
var vwand1 = "vigor wand D *max +9"
var vwand2 = "vigor wand D *max +0"
//aether:
var aesword = "aether sword D *max"
var dUsword1 = "aether sword dU *max +15 -big"
var dUSWORD2 = "big aether sword dU *max +15"
var aeshield = "aether shield -au *max"
var auShield = "aether shield au *max"
var aebow = "aether crossbow D *max"
//fire:
var dFsword = "fire sword dF *max"
var fsword = "fire sword D *max"
var fshield = "fire shield A *max"
var fbow = "fire crossbow dF *max"
var dFwand = "fire wand dF *max"
//ice:
var dIsword = "ice sword dI *max -big"
var dISWORD2 = "big ice sword dI *max"
var isword = "ice sword D *max"
var ishield = "ice shield A *max"
var aiShield = "ice shield ai *max"
var dIwand1 = "ice wand dI *max +16"
var dIwand2 = "ice wand dI *max +0"
var ibow = "ice crossbow D *max"
//alternate:
var altbow = "crossbow *max golden"
//special weapons:
var dshield = "dashing shield *max"
var myqstaff = "quarterstaff golden"
var fastBard = "bardiche *max" // enchanted: speed
var cshield1 = "compound shield *max shiny"
var cshield2 = "compound shield *max -shiny"
var rbow = "repeating crossbow *max"



// Weapons damage

var bladeDmg = 310
var bladeRDmg = 95
var smiteMult = 8.8 // mult = multiplier

var armDmg = 44
var armRDmg = armDmg / 2
var maxArmBuffs = 3

var taliRDmg = 32 // multiplied by the amount of Ignition buffs
var maxIgnitions = 15

var hammDmg = 123

/* WARNING: These stats are for 
"Kubikiribocho" only, not for the
other bardiche! */
var bardDmg = 52
var bardCrit = 10.8
var bardRDmg = (bardDmg + 17) * bardCrit


// *******************************************************
//                 END OF "MyArsenal.txt"                 
// *******************************************************

// *******************************************************
//                    Speed_O_Meter.txt                   
// *******************************************************


// VARIABLES

// Times in seconds:
var ttDigital = myFormatDigital(tt)
var pb = myFormatDigital(lbt)
var avg = myFormatDigital(lavg)

// Variable updating frequency:
?tt % 30 = 0
  ttDigital = myFormatDigital(tt)
?loc.loop
  pb = myFormatDigital(lbt)
  avg = myFormatDigital(lavg)



// Public:

// FUNCTIONS

func speedOmeterUpdate(isSpeedrun)
  ?isSpeedrun
    return true
  :
    return tt % 30 = 0

func showSpeedOmeterUI(x,y,colorStr,isSpeedrun)
  var txt

  ?isSpeedrun
    txt = ui.AddText(
    ^"   SPEED-O-METER" + "\n" +
    ^"···················" + "\n" +
    ^" CUR " + ttDigital + " (" + tt + "f)" + "\n" +
    ^" PB  " + pb + " (" + lbt + "f)" + "\n" +
    ^" AVG " + avg + " (" + lavg + "f)"               )

  :
    txt = ui.AddText(
    ^"SPEED-O-METER" + "\n" +
    ^"·············" + "\n" +
    ^"  CUR " + ttDigital + "\n" +
    ^"  PB  " + pb + "\n" +
    ^"  AVG " + avg              )

  txt.anchor = top_left
  txt.dock = top_left

  txt.x = 1
  txt.y = 1

  ?isSpeedrun
    txt.w = 19
  :
    txt.w = 13
  txt.h = 5



  var panel

  panel = ui.AddPanel()
  panel.Add(txt)
  
  panel.style = -2
  
  panel.anchor = top_left
  panel.dock = top_left
  
  panel.x = x
  panel.y = y
  
  panel.w = txt.w + 2
  panel.h = txt.h + 2

  ?colorStr
    txt.color = colorStr
    panel.color = colorStr

  return panel


// *******************************************************
//               END OF "Speed_O_Meter.txt"               
// *******************************************************



?l = "Ridge"
  // VARIABLES
  var keepMask = true
  var smiteScr = 1
  var weaverScr = 3

  var keepFTali = false
  
  ?f = "boss"
    keepFTali = true

  ?ll
    keepFTali = false
    keepMask = false
    ?smiteScr = 1 & ls > 10
      smiteScr = 2

  var blowing
  
  var canDebI
  var canDebP
  var canDebF
  
  // LOADOUTS:
  
  func ldtF(mode)
  
    ?mode = "default"
      equipL triskelion
      ?!keepMask
        equipR @cshield1@
    :?mode = "armorRegen"
      equipL triskelion
      ?!keepMask
        equipR @cshield2@
    :?mode = "engage"
      equipL triskelion
      ?!keepMask
        equipR @fshield@
    :?mode = "escape"
      equipL mind
      ?!keepMask
        equipR @fshield@
    :?mode = "magnet"
      equipL star
      ?!keepMask
        equipR triskelion
  
    :?mode = "magic"
      ?keepMask
        ?canDebI
          equipL @dIwand1@
        :?canDebP
          equipL @dPwand@
        :?canDebF
          equipL @dFwand@
      :
        //Left hand:
        ?canDebP
          equipL @dPwand@
        :?canDebF
          equipL @dPwand@
        :?canDebI
          equipL @dIwand2@
        
        //Right hand:
        ?canDebI
          equipR @dIwand1@
  
    :?mode = "meleeDmg"
      equipL Vantum Phoenix
      ?!keepMask
        ?fd <= 5
          equipR moon
        :
          equipR @auShield@
    :?mode = "meleeDef1"
      equipL @dFsword@
      ?!keepMask
        equipR @fshield@
  
    :?mode = "armorDmg"
      equipL @fhammer1@
      ?!keepMask
        equipR @fhammer2@
  
    :?mode = "unmkDmg"
      ?!keepMask
        equipL @dUsword1@
        equipR @dUSWORD2@
      :
        ?foe.GetCount(10) > 1
          equipL @dUSWORD2@
        :
          equipL @dUsword1@
    :?mode = "unmkDef"
      equipL @dUSWORD2@
      ?!keepMask
        equipR @auShield@
  
    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@
    return
  
  // FUNCTIONS:
  
  // Useful for miniboss too
  func fight1v1()
    fds = foe.debuffs.string


    /* How to apply debuffs:
    - apply all except the ones the foe is immune to.
    Finish when:
    - all possible debuffs have been applied. */
    canDebI = (fds ! "chill:6" & f ! "immune_to_debuff_chill")
    
    canDebP = (fds ! "damage" & f ! "immune_to_debuff_damage")
    
    canDebF = (fds ! "dot" & f ! "immune_to_debuff_dot")
    
    ?canDebI | canDebP | canDebF
      ?keepMask
        ?canDebI
          equipL @dIsword@
        :?canDebP
          equipL @dPsword1@
        :?canDebF
          equipL @dFsword@
      :
        //Left hand:
        ?canDebP
          equipL @dPsword1@
        :?canDebF
          equipL @dFsword@
        :?canDebI
          equipL @dIwand1@

        //Right hand:
        ?canDebI
          equipR @dIsword@
    :
      ?keepMask
        equipL Vantum Phoenix
      :
        bs = buffs.string
        ?bs = "berserk"
          doMoondial(Vantum Phoenix, fsword, 2)
        :
          doMoondial(Vantum Phoenix, fsword, 0)

    return
  
  // PROCEDURE:
  
  var somui = showSpeedOmeterUI(1,6,colorToHex("pink"),false)
  ?speedOmeterUpdate(false)
    somui = showSpeedOmeterUI(1,6,colorToHex("pink"),false)


  /* Mano izquierda:
  --- hacer AAC ---
  - cuando state = 3
  --- NO hacer AAC ---
  - Cuando tenemos la mascara puesta y el arma equipada es una espada D +21. */
  ?ils = 3 & !(keepMask & il = "sword D +21")
    equipL wand 0*
    equipL @il@
  ?irs = 3 & ir ! "sword D +21"
    equipR @cshield2@
    equipR @ir@

  ?hp < maxhp
    loc.Leave()

  ?lb & ip ! "berserk"
    brew wood + bronze

  ?keepMask
    equipR mask

  ?lb | ll
    equipL triskelion
    equipR @cshield1@

  :?canUseAETali() & !keepFTali
    ?keepMask
      useAETali("l")
    :
      equipL triskelion
      useAETali("r")
  /*:?canUseFTali() & keepFTali
    ?keepMask
      useFTali("l")
    :
      equipL triskelion
      useFTali("r")*/

  :?canUsePotDmg() & keepMask
    activate potion

  :?pickup.distance ! 9999
    ?canUseQstaff()
      useQstaff(myqstaff)
    :
      ldtF("magnet")

  :
    fd = foe.distance
    fs = foe.state

    ?f ! "yeti"
      si = screen.i
      bs = buffs.string

      ?canUseBladeDS(smiteScr)
        ?fd <= 33 & getBuffInfo("smite",false,2) < 25
          useBladeDS()

      ?canUseMaskDS(4)
        ?getBuffInfo("smite",false,2) >= 25
          useMaskDS()

      ?canUseQstaff() &
      ^ir ! "bardiche" & ir ! Kubikiribocho &
      ^ir ! "heavy hammer" & (
      ^((canBash() | canDash()) & fd > 15)
      ^| !(canBash() | canDash()))
        useQstaff(myqstaff)

      :?fd > 35
        pa = armor
        ?14 <= pa & pa <= 29
          ldtF("default")
        :?pa < 14
          ldtF("armorRegen")
        :
          equipL triskelion
          equipR mask

      :?fd > 15
        ldtF("engage")
        
        var isAbtToDash
        isAbtToDash = (fd <= 17)
        ?keepMask & isAbtToDash
          equipR @fshield@

        canDebI = (fds ! "chill" &
        ^f ! "immune_to_debuff_chill")

        ?!keepMask & canDebI & isAbtToDash &
        ^getFoeTotalHP() > getBuffInfo("smite", false, 2) * smiteMult
          equipR @aiShield@

      :?canBash()
        bash(dIsword)
      :?canDash()
        dash(dIsword,dshield)

      :
        fn = foe.name
        fc = foe.count
        fds = foe.debuffs.string

        ?canUseHamm() & (
        ^(smiteScr = 1 & si = 3) |
        ^(smiteScr = 2 & si = 1)   )
          useHamm()

        :?f = "spawner" | fn = "Ice Wall"
/**********************************
          ?canUseWeaver()
            ?fc = 1 & fd < 15
              useWeaver()
// *********************************/

          ?fd <= 6 | aiI
            ldtF("unmkDmg")
          :?fd > 10
            equipL triskelion
            equipR @dUsword1@
          :
            ldtF("unmkDef")
        :
          ?fn = "Giant Ice Elemental" // the miniboss
            bs = buffs.string

            ?canUseMask()
              useMask()
            :?canUseBard() & bs = "berserk" & keepMask
              useBard(Kubikiribocho)
            :
              fight1v1()

          :?fc = 1
            fight1v1()

          :
            canDebI = (fds ! "chill:6" & f ! "immune_to_debuff_chill")

            canDebP = (fds ! "damage" & f ! "immune_to_debuff_damage")

            canDebF = (fds ! "dot" & f ! "immune_to_debuff_dot")
      
            ?canDebI | canDebP | canDebF
              ldtF("magic")
            :
              ?fd <= 6
                ldtF("unmkDmg")
              :
                ldtF("unmkDef")


    :?f = "yeti" & fs ! 4
      ft = foe.time

/**********************************/
      ?canUseWeaver()
        ?fd < 15
          useWeaver()
// *********************************/

      ?canUseQstaff() &
      ^fd > 15 & fs ! 1
        useQstaff(myqstaff)

      ?fs = 1 & ft = 1
        loc.Pause()

      :?canBash()
        bash(Vantum Phoenix)
      :?canDash()
        dash(Vantum Phoenix,dshield)

      :?fa > 0 & canUsePotDmg()
        activate potion
      :
        fight1v1()

// *******************************************************
//                      END OF FILE
// *******************************************************
