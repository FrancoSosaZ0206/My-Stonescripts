/*var mind = import UI/MindstoneButton

mind.SetXY(1,13)*/

// *******************************************************
//                       1-Rocky.txt                      
// *******************************************************

// Script for Rocky Plateau


// IMPORTS

// *******************************************************
//                     Utilities.txt                      
// *******************************************************

// VARIABLES:

//Units

var sec = 30 // frames

//FUNCTIONS:

func myFormatDigital(frames)
  ?frames <= 0
    return "00:00"
  :
    var timeStr
    var secs
    var mins
    var secStr
    var minStr

    secs = frames/30
    mins = (frames/30)/60

    secs -= mins*60

    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins
      
    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
    
    return minStr + ":" + secStr


// *******************************************************
//                 END OF "Utilities.txt"                 
// *******************************************************

// *******************************************************
//                    PerformanceV2.txt                   
// *******************************************************


// VARIABLES - definitions


//Location
var l = loc
var ls = loc.stars
var lavg = loc.averageTime
var lbt = loc.bestTime
var lb = loc.begin
var ll = loc.loop


// Foe
var f
f = foe
var fn
var fbs
var fds
var fd
var fc
var fs
var ft
var fhp
fhp = foe.hp
var fa
fa = foe.armor
var fdmg

// Time
var tt
tt = totaltime

// Item
var ip
ip = item.potion
var il
il = item.left
var ils
ils = item.left.state
var ilt
var ili

var ir
ir = item.right
var irs
irs = item.right.state
var irt
var iri

// Player stats
var php
var pmhp
pmhp = maxhp
var pa
var pma
var ds
var bs

// Ai
var aiE
var aiI
aiI = ai.idle


//screen
var si
si = screen.i


//resources
var rs // res.stone
var rw // res.wood
var rt // res.tar
var rb // res.bronze
var rk // res.ki
var rc // res.crystals


// Functions
var canAct
canAct = item.CanActivate()

// Cooldowns
var bladeCd = 80 * sec
var maskCd = 48 * sec
var armCd = 39 * sec
var taliCd = 5 * sec
var cindCd = 90 * sec

var bardCd = 30 * sec
var hammCd = 22 * sec
var mindCd = 12 * sec // currently not in use
var qstaffCd = 5 * sec + 15 // 5,5s
var dashCd = sec + 15 // 1,5s
var bashCd = 9 * sec

// Cast times
var castTime = sec

// Delays
var bladeDelay = 0
var maskDelay = 0
var armDelay = 0
var taliDelay = 0
var cindDelay = 0

var bardDelay = 0
var hammDelay = 0
var mindDelay = 0 // currently not in use
var qstaffDelay = 0
var dashDelay = 0
var bashDelay = 0

?tt < 3
  lb = loc.begin
  ll = loc.loop
?tt = 1
  lavg = loc.averageTime
  lbt = loc.bestTime

  bladeDelay = 0
  maskDelay = 0
  armDelay = 0
  taliDelay = 0
  cindDelay = 0

  bardDelay = 0
  hammDelay = 0
  mindDelay = 0 // currently not in use
  qstaffDelay = 0
  dashDelay = 0
  bashDelay = 0

// *******************************************************
//               END OF "PerformanceV2.txt"               
// *******************************************************

// *******************************************************
//                    MyBetterInfo.txt                    
// *******************************************************


// FUNCTIONS



func colorToHex(colorName)
  ?colorName = "red"
    return #FF0000
  :?colorName = "orange"
    return #FF7518
  :?colorName = "yellow"
    return #FFFF00
  :?colorName = "gold"
    return #E49B0F
  :?colorName = "blue"
    return #0000FF
  :?colorName = "cyan"
    return #00FFFF
  :?colorName = "magenta"
    return #FF00FF
  :?colorName = "pink"
    return #E0115F
  :?colorName = "purple"
    return #800080
  :?colorName = "violet"
    return #7F00FF
  :?colorName = "green"
    return #008000
  :?colorName = "darkGreen"
    return #023020
  :?colorName = "white"
    return #FFFFFF
  :?colorName = "gray"
    return #808080
  :?colorName = "black"
    return #000000
  :?colorName = "brown"
    return #7B3F00
  :?colorName = "turquoise" | colorName = "turquesa"
    return #40E0D0
  :?colorName = "rainbow" | colorName = "rgb"
    return #rainbow
  :
    >c-20,0,#red,ERROR: colorToHex() got unexisting color: @colorName@


func makeTextbox(x,y,w,h,txtStr,colorName,styleID)

  //declarations:
  var panel
  var txt

  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(txtStr)


  //adding style and text to the panel:
  panel.style = styleID
  panel.Add(txt)

  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left

  //adding color
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)

  //adding position
  panel.x = x
  panel.y = y

  txt.x = 1
  txt.y = 1

  //adding wide and height
  panel.w = txt.w + w
  panel.h = txt.h + h

  return panel

func makeButton(x,y,w,h,anchor,dock,txtStr,colorName,styleID,actionFunc)
  var btn

  btn = ui.AddButton()

  btn.x = x
  btn.y = y

  btn.text = txtStr

  btn.w = string.Size(btn.text) + w
  btn.h = h

  ?anchor
    btn.anchor = anchor
  ?dock
    btn.dock = dock


  ?styleID
    btn.style = styleID

  ?colorName
    var colorID = colorToHex(colorName)
    btn.tcolor = colorID
    btn.bcolor = colorID
    btn.hcolor = colorID
  
  btn.SetPressed(actionFunc)

  return btn


func showBigStrUI(str,maxwidth,x,y,colorID)

  //declarations:
  var panel
  var txt

  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(str)


  //adding style and text to the panel:
  panel.style = -1
  panel.Add(txt)

  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left

  //adding color
  ?colorID
    txt.color = colorToHex(colorID)
    panel.color = colorToHex(colorID)

  //adding position
  panel.x = x
  panel.y = y

  txt.x = 1
  txt.y = 1

  txt.w = maxwidth

  //adding wide and height
  panel.w = txt.w + 2
  panel.h = txt.h + 2

  return panel


func showStrCentered(str,y,maxW,colorName)
  ?string.Size(str) <= maxW
    >c@-(string.Size(str)-1)/2@,@y@,@colorToHex(colorName)@,@str@
  :
    var arrStr = string.Break(str,maxW)
    ?arrStr
      for i = 0 .. arrStr.Count() - 1
        >c@-(string.Size(str)-1)/2@,@y-((arrStr.Count()-1))/2+i@,@colorToHex(colorName)@,@arrStr[i]@

  return


// *******************************************************
//               END OF "MyBetterInfo.txt"                
// *******************************************************

// *******************************************************
//                       Combat.txt                       
// *******************************************************


// VARIABLES


// Status

var midhp = pmhp / 2
var lowhp = pmhp / 3
var hihp = (4 * pmhp) / 5


// FUNCTIONS



// Stats


/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getDebuffLvl(nameid,inFoe)
// if inFoe = true, checks foe's debuffs, else, player's debuffs
  var lvl
  var debuffFound
  var arrDebuffs

  ?inFoe
    arrDebuffs = string.Split(fds,",", true)
  :
    arrDebuffs = string.Split(ds,",", true)

  ?arrDebuffs & !debuffFound
    for debuff : arrDebuffs
      ?debuff = nameid
        var arrInfo = string.Split(debuff,":",true)

        lvl = int.Parse(arrInfo[2])
        debuffFound = true

    ?debuffFound = true
      return lvl
    :
      return 0


func getFoeTotalHP()
  return fhp + fa



// Lost items


func canUseMask()
  return tt >= maskDelay & canAct

func useMask()
  equipL triskelion
  equipR mask
  activate R

  maskDelay = tt + maskCd

  return


func canUseTali()
  return summon.count = 0 &
  ^tt >= taliDelay &
  ^canAct |
  ^(il = talisman & ils = 2) |
  ^(ir = talisman & irs = 2)

func useTali(hand)
  ?hand = "l"
    equipL talisman
    activate L
  :?hand = "r"
    equipR talisman
    activate R

  taliDelay = tt + taliCd + castTime

  return

/* Checks if you can use the cinderwisp's "devour"
ability. */
func canUseCind()
  return summon.count >= 1
  ^& summon.GetId() = "cinderwisp"
  ^& tt >= cindDelay & canAct

/* Checks if the estimated damage of
cinderwisp's "devour" ability will kill the foe,
leaving a damage margin.
  - cindDmg: represents the damage the cinderwisp does,
             which will be multiplied by each ignition
             debuff applied.
  - margin: number representing a health margin to add
            to the remaining foe's health. This is
            necessary because the ability has a cast time
            that will alter the estimations done here.
            Send 0 if you don't want to use a margin. */
func canKillCind(cindDmg,margin)
  return getFoeTotalHP() <= (getDebuffLvl("ignition",true) * cindDmg) + margin

func useCind()
  activate cinderwisp
  cindDelay = tt + cindCd + castTime
  return


/* Checks if you can use the
bashing shield's ability. */
func canBash()
  return tt >= bashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct

func bash(lItem)
  equipL @lItem@
  equipR bashing shield

  bashDelay = tt + bashCd

  return




// Special Weapons


func canUseHamm()
  return tt >= hammDelay &
  ^canAct |
  ^(ir = heavy hammer &
  ^irs = 2)

var hammCdSlower
func canUseHamm2()
  hammCdSlower = item.GetCooldown("hammer") <= 0
  return hammCdSlower &
  ^canAct |
  ^(ir = "heavy hammer" &
  ^irs = 2)

func useHamm()
  equip heavy hammer
  activate R

  hammDelay = tt + hammCd + castTime

  return


func canUseBard()
  return tt >= bardDelay &
  ^canAct |
  ^(ir = bardiche &
  ^irs = 2)

var bardCdSlower
func canUseBard2()
  bardCdSlower = item.GetCooldown("bardiche") <= 0
  return bardCdSlower &
  ^canAct |
  ^(ir = "bardiche" &
  ^irs = 2)

func useBard(yourBard)
  ?fd < 10
    equip @yourBard@
    activate R

    bardDelay = tt + bardCd + castTime

  return


/* Checks if you can use the
dashing shield's ability. */
func canDash()
  return tt >= dashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct

func dash(lItem,yourDshield)
  equipL @lItem@
  equipR @yourDshield@

  dashDelay = tt + dashCd

  return


func canUseQstaff()
  ?tt >= qstaffDelay

    return canAct |
    ^(ir = quarterstaff
    ^& irs = 2)
  :
    return false

// recieves a string
func useQstaff(yourQuarterstaff)
  equip @yourQuarterstaff@
  activate R

  qstaffDelay = tt + qstaffCd

  return

func canUseMind()
  return item.GetCooldown("mind") <= 0 & canAct



// Potions


func canUsePot()
  return ip ! empty & canAct

/* Determines if a damage buff potion
is brewed. Generally used for bosses.
Potions related:
  - berserk
  - lucky */
func canUsePotDmg()
  return canUsePot() &
  ^(ip = "berserk" | ip = "lucky")



// Others

var moonTimer = 0
var moonFrame
func doMoondial(weapon1, weapon2, mode)
  ?mode = 0 // Normal moondialing
    moonTimer++
    moonFrame = moonTimer % 3

    ?moonFrame = 1
      equipL moon
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?mode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moonTimer++
    moonFrame = moonTimer % 4

    ?moonFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon1@
    :?moonFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moonFrame = 4
      equipL moon
      equipR @weapon2@
  
  :?mode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@

  :?mode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    ?fd <= 5
      equipL moon
    :
      equipL @weapon2@
    equipR @weapon1@


  return


// *******************************************************
//                  END OF "Combat.txt"                   
// *******************************************************

// *******************************************************
//                     MyArsenal.txt                      
// *******************************************************


// VARIABLES:


/* renamed:

Mamba Negra = poison sword D *max
Dothaneel = vigor sword D *max
Void Slayer = aether sword D *max
Vantum Phoenix = fire sword D *max
Bifrost = ice sword D *max
Speedy Hammer = stone hammer *max
Kubikiribocho = bardiche *max (enchanted: crit) */

//poison:
var dPsword1 = "poison sword dP *max +13" // enchanted: speed
var dPsword2 = "poison sword dP +0" // enchanted: debuff
var psword = "poison sword D *max"
//vigor:
var dLsword = "vigor sword dL *max"
var vsword = "vigor sword D *max Spring24"
var ahShield = "vigor shield ah *max"
var ahHammer = "vigor hammer ah *max"
//aether:
var aesword = "aether sword D *max"
var aebow = "aether crossbow D *max"
//fire:
var dFsword = "fire sword dF *max"
var fsword = "fire sword D *max"
//ice:
var dIsword = "ice sword dI *max"
var isword = "ice sword D *max"
var ibow = "ice crossbow D *max"
//special weapons:
var dshield = "dashing shield *max golden"
var myqstaff = "quarterstaff golden"
var fastBard = "bardiche *max" // enchanted: speed
var cshield1 = "compound shield *max shiny"
var cshield2 = "compound shield *max -shiny"



// Weapons damage

var bladeDmg = 310
var bladeRDmg = 93
var smiteMult = 8.8 // mult = multiplier

var armDmg = 44
var armRDmg = armDmg / 2
var maxArmBuffs = 3

var taliRDmg = 32 // multiplied by the amount of Ignition buffs
var maxIgnitions = 15

var hammDmg = 123

/* WARNING: These stats are for 
"Kubikiribocho" only, not for the
other bardiche! */
var bardDmg = 52
var bardCrit = 10.8
var bardRDmg = (bardDmg + 17) * bardCrit


// *******************************************************
//                 END OF "MyArsenal.txt"                 
// *******************************************************

// *******************************************************
//                    Speed_O_Meter.txt                   
// *******************************************************


// VARIABLES

// Times (in seconds):
var ttDigital = myFormatDigital(tt)
var pb = myFormatDigital(lbt)
var avg = myFormatDigital(lavg)

// Variable updating frequency:
?tt % 30 = 0
  ttDigital = myFormatDigital(tt)
?ll
  pb = myFormatDigital(lbt)
  avg = myFormatDigital(lavg)



// Public:

// FUNCTIONS

func speedOmeterUpdate(isSpeedrun)
  ?isSpeedrun
    return true
  :
    return tt % 30 = 0

func showSpeedOmeterUI(x,y,colorStr,isSpeedrun)
  var txt

  ?isSpeedrun
    txt = ui.AddText(
    ^"   SPEED-O-METER" + "\n" +
    ^"···················" + "\n" +
    ^" CUR " + ttDigital + " (" + tt + "f)" + "\n" +
    ^" PB  " + pb + " (" + lbt + "f)" + "\n" +
    ^" AVG " + avg + " (" + lavg + "f)"               )

  :
    txt = ui.AddText(
    ^"SPEED-O-METER" + "\n" +
    ^"·············" + "\n" +
    ^"  CUR " + ttDigital + "\n" +
    ^"  PB  " + pb + "\n" +
    ^"  AVG " + avg              )

  txt.anchor = top_left
  txt.dock = top_left

  txt.x = 1
  txt.y = 1

  ?isSpeedrun
    txt.w = 19
  :
    txt.w = 13
  txt.h = 5



  var panel

  panel = ui.AddPanel()
  panel.Add(txt)
  
  panel.style = -2
  
  panel.anchor = top_left
  panel.dock = top_left
  
  panel.x = x
  panel.y = y
  
  panel.w = txt.w + 2
  panel.h = txt.h + 2

  ?colorStr
    txt.color = colorStr
    panel.color = colorStr

  return panel



// *******************************************************
//               END OF "Speed_O_Meter.txt"               
// *******************************************************

// *******************************************************
//                 DPS_Meter_MODIFIED.txt                 
// *******************************************************


// GLOBAL VARIABLES

// Already defined in Utilities.txt:
// var sec = 30    // 1 sec = 30 frames

var dpstt       // total time, on in-game frames
var currhp = 0  // foe's current hitpoints (with armor) 
var nethp = 0   // foe's net maximum hitpoints (with armor) 
var dpsf        // foe

dpstt  = totaltime
currhp = foe.hp + foe.armor
nethp  = foe.maxhp + foe.maxarmor
dpsf   = foe

var hits      = 0 // hit counter
var dmg       = 0 // current damage dealt
var totalDmg  = 0 // total damage dealt
var startTime = 0 // timestamp for the beginning of the fight
var auxhp     = 0 // auxiliar variable to compare with currhp

var FRM = "N/A" // frames elapsed from first hit
var FPH = "N/A" // frames per hit >>> hit frequency | frames elapsed from each hit to the next
var HPS = "N/A" // hits per second
var DPF = "N/A" // damage per frame
var DPS = "N/A" // damage per second



//PROCEDURE

// Calculate only when desired:
?DPSMeterEnabled

  ?dpsf = "boss" // only works when there's a boss
    ?0 < currhp & currhp < nethp // boss lost hp/armor, but isn't dead
      ?auxhp > currhp // if current hp updates
        hits += 1 // we count a hit
        dmg       = auxhp - currhp // we get the damage dealt from the difference
        totalDmg  = totalDmg + dmg // and we accumulate it in this variable
    : // else, reset temporal variables
      startTime = dpstt
      hits      = 0
      dmg       = 0
      totalDmg  = 0
  
    FRM = dpstt - startTime // total time minus the time the first hit was dealt
    ?hits > 1
      FPH = FRM      / (hits-1) // -1 is there to avoid stat flicking
    :
      FPH = "N/A"
  
    ?FPH ! "N/A"
      HPS = sec      / FPH
    :
      HPS = "N/A"
      
    ?FRM > 0
      DPF = totalDmg / FRM // damage accumulated - no. frames elapsed
    :
      DPF = "N/A"
    ?DPF ! "N/A"
      DPS = DPF  * sec
    :
      DPS = "N/A"



// Private (do not use/modify!):

func dpsUpdate()
  ?DPSMeterEnabled
    auxhp = currhp
  return


var hits_old
var HPS_old
var dmg_old
var DPF_old
var DPS_old

func dpsMeterUpdate()
  ?!DPSMeterEnabled
    return false
  :?dpsf = "boss" &
  ^(hits_old ! hits | HPS_old ! HPS |
  ^dmg_old ! dmg | DPF_old ! DPF |
  ^DPS_old ! DPS)
    ?hits_old ! hits
      hits_old = hits
    ?HPS_old ! HPS
      HPS_old = HPS
    ?dmg_old ! dmg
      dmg_old = dmg
    ?DPF_old ! DPF
      DPF_old = DPF
    ?DPS_old ! DPS
      DPS_old = DPS

    return true
  :
    return false


// Public:

var DPSMeterEnabled = false

// Returns ui pannel containing the information.
func uiDPSMeter(x,y,colorStr)
  var panel

  var txt
  
  ?DPSMeterEnabled
    
    panel = ui.AddPanel()
    txt = ui.AddText( "   DPS METER   "   + "\n" +
    ^                 "···············"   + "\n" +
    ^                 " hits     " + hits_old + "\n" +
    ^                 " hits/s   " + HPS_old  + "\n" +
    ^                 " dmg /hit " + dmg_old  + "\n" +
    ^                 " dmg /f   " + DPF_old  + "\n" +
    ^                 " dmg /s   " + DPS_old  + "\n" +
    ^                 "···············"     )
  
    panel.style = 3
    panel.Add(txt)
    
    panel.anchor = top_left
    panel.dock = top_left
    txt.anchor = top_left
    txt.dock = top_left
    
    panel.color = colorStr
    txt.color = colorStr
  
    panel.x = x
    panel.y = y
    
    txt.x = 1
    txt.y = 1
    
    txt.w = 15
    txt.h = 8
  
    panel.w = txt.w + 2
    panel.h = txt.h + 2
  
    dpsUpdate()
  return panel


// *******************************************************
//             END OF "DPS_Meter_MODIFIED.txt"            
// *******************************************************


?l = "Rocky"
  // FUNCTIONS

  func harvFunc(btn)
    btnPressed = true
    ?btn = yesBtn
      choice = true
    : // btn = noBtn
      choice = false
    
    return

  func bossFight()

    ?f = "phase1"
      ?!keepMask & php = pmhp
        ?bs = "berserk"
          ldtF("fdmg")
        :
          doMoondial(Vantum Phoenix, fsword,0)
      :
        equipL Vantum Phoenix

    :?f = "phase2"
      ?f = "poison"
        ?!keepMask & php = pmhp
          ?bs = "berserk"
            ldtF("idmg")
          :
            doMoondial(Bifrost, isword,0)
        :
          equipL Bifrost
      :?f = "vigor"
        ?!keepMask & php = pmhp
          ?bs = "berserk"
            ldtF("pdmg")
          :
            doMoondial(Mamba Negra, psword,0)
        :
          equipL Mamba Negra
      :?f = "aether"
        ldtF("vDmg")
      :?f = "fire"
        ldtF("aeDmg")
      :?f = "ice"
        ?!keepMask & php = pmhp
          ?bs = "berserk"
            ldtF("fdmg")
          :
            doMoondial(Vantum Phoenix, fsword,0)
        :
          equipL Vantum Phoenix

    : // ?foe = phase3
      ?canUsePotDmg()
        activate potion
      :?canUseMask()
        useMask()

      ?canUseCind()
        var cindMargin
        ?ls >= 13
          cindMargin = 1000
        :
          cindMargin = 3000
        ?fds = "ignition:15" |
        ^canKillCind(taliRDmg,cindMargin)
          useCind()
          
      ft = foe.time

      ?((fs = 115 & ft < 70) |
      ^(fs = 32 & fdmg = 1))
      ^& ft >= 42 // putting up shield
        dontDash = true

        ?canUseMind()
          ldtF("escape")
        :?fd > 7
          equip @aebow@
        :?canUseMask()
          useMask()
      :
        dontDash = false
        ?fa > 0 & canUseHamm2() &
        ^!bardCdSlower & fd < 11
          useHamm()
        :
          ?fbs ! "defense_fire"
            ?!keepMask & php = pmhp
              ?bs = "berserk"
                ldtF("fdmg")
              :
                doMoondial(Vantum Phoenix, fsword,0)
            :
              equipL Vantum Phoenix
          :
            ?!keepMask & php = pmhp
              ?bs = "berserk"
                ldtF("idmg")
              :
                doMoondial(Bifrost, isword,0)
            :
              equipL Bifrost


    ?php < pmhp
    ^& !canBash() & !canDash()
    ^& !keepMask
      equipR @dLsword@


    return


  // LOADOUTS

  func ldtF(mode)
    ?mode = "default"
      equipL triskelion
      ?!keepMask
        equipR @cshield1@
    :?mode = "armorRecover"
      equipL triskelion
      ?!keepMask
        equipR @cshield2@
    :?mode = "escape"
      equipL mind
      equipR @cshield2@

      mindDelay = tt + mindCd
    :?mode = "magnet"
      equipL star
      ?!keepMask
        equipR triskelion

    :?mode = "harv"
      equip shovel

    //buffs/debuffs (oriented to duration)
    :?mode = "pDeb1"
      equipL @dPsword1@
      equipR mask
    :?mode = "pDeb2"
      equipL @dPsword1@ // put 2 when upgraded back to normal
      equipR mask
    :?mode = "aidActive"
      equipL @ahHammer@
      equipR @ahShield@
      
    :?mode = "fDeb"
      equipL @dFsword@
      equipR mask
    :?mode = "iDeb"
      equipL @dIsword@
      equipR mask
    //damage
    :?mode = "fDmg"
      equipL Vantum Phoenix
      ?!keepMask
        equipR @fsword@
    :?mode = "iDmg"
      equipL Bifrost
      ?!keepMask
        equipR @isword@
    :?mode = "pDmg"
      equipL Mamba Negra
      ?!keepMask
        equipR @psword@
    :?mode = "vDmg"
      equipL Dothaneel
      ?!keepMask
        equipR @vsword@
    :?mode = "aeDmg"
      equipL Void Slayer
      ?!keepMask
        equipR @aesword@

    :?mode = "sdmg"
      equipL @sSword1@
      ?!keepMask
        equipR @sSword2@

    : // print error message on screen
      showStrCentered(
      ^"ERROR: ldtF() recieved incorrect mode: " + mode,
      ^0, 30, "yellow")

    return 


  // VARIABLES

  var dontDash
  var trueDmg

  var nRuns = 0

  var keepMask = true
  ?ll
    keepMask = false
    ?tt = 1
      nRuns++


  // PROCEDURE

  var somui = showSpeedOmeterUI(1,6,colorToHex("pink"),false)
  ?speedOmeterUpdate(false)
    somui = showSpeedOmeterUI(1,6,colorToHex("pink"),false)

  DPSMeterEnabled = false
  var dpsPanel
  ?dpsMeterUpdate()
    dpsPanel = uiDPSMeter(1,13,"#yellow")


  var choice = false
  var btnPressed = false

  var yesBtn
  var noBtn

  var dontShowAgain = false


  ?!btnPressed
    ?!yesBtn
      yesBtn = makeButton(
      ^-5,9,4,4,null,null,
      ^"Yes","green",-5,harvFunc)
    ?!noBtn
      noBtn = makeButton(
      ^5,9,5,4,null,null,
      ^"No","red",-5,harvFunc)

    showStrCentered("Harvest boulders?",6,30,"yellow")

  :
    ?yesBtn
      yesBtn.Recycle()
      yesBtn = null
    ?noBtn
      noBtn.Recycle()
      noBtn = null

    ?!dontShowAgain
      var aux = tt + 3*sec
      ?tt < aux
        ?choice
          showStrCentered("Harvest boulders is enabled",6,30,"green")
        :
          showStrCentered("Harvest boulders is disabled",6,30,"red")
      :
        ?!dontShowAgain
          dontShowAgain = true

  /* Mano izquierda:
  --- hacer AAC ---
  - cuando state = 3
  --- NO hacer AAC ---
  - Cuando tenemos la mascara puesta y el arma equipada es una espada D +21. */
  ?ils = 3 & !(keepMask & il = "sword D +21")
    equipL wand 0*
    equipL @il@
  ?irs = 3 & ir ! "sword D +21"
    equipR @cshield2@
    equipR @ir@


  ?debuffs.string | (tt > lavg & nRuns >= 2)
    loc.Leave()

  ?lb
    rs = res.stone
    rb = res.bronze
    ?rs >= 10 & rb >= 10
      ?ip ! "lucky"
        brew stone + bronze
    :
      loc.Leave()

    /*rw = res.wood
    rb = res.bronze
    ?rw >= 10 & rb >= 10
      ?ip ! "berserk"
        brew wood + bronze
    :
      loc.Leave()*/

  ?keepMask
    equipR mask

  ?lb | ll
    /* ldtF("default") but w/o considering keepMask*/
    equipL triskelion
    equipR @cshield1@

  :?canUseTali()
    equipL triskelion
    useTali("r")
    
  :?canUsePotDmg() & keepMask
    activate potion

  :?choice & harvest.distance < 5
    ldtF("harv")

  :?pickup.distance < 15
    ldtF("magnet")

  :
    fd = foe.distance
    fs = foe.state
    fdmg = foe.damage
    php = hp
    pmhp = maxhp

    aiE = ai.enabled

    ?f = "dysangelos" & fd <= 22
    ^& canUseBard2() &
    ^(fs = 100 | fs = 101 |
    ^fs = 102 | fs = 126)
      ?canUseHamm2()
        useHamm()
      :?canUseQstaff()
        useQstaff(myqstaff)
      :?canDash()
        dash(Vantum Phoenix, dshield)
      :
        ?bs = "berserk"
          useBard(Kubikiribocho)
        :
          useBard(fastBard)

    :?fd > 15 | !aiE |
    ^(fs = 124 | fs = -1 |
    ^(fs = 107 & fdmg = 3)) // Dysan's flying animation (after putting shield on phase3)
      fa = armor
      ?14 <= fa & fa <= 29
        ldtF("default")
      :
        ldtF("armorRecover")
        
    :?aiE & fs ! -1
      // fighting range

      f = foe
      fbs = foe.buffs.string
      fds = foe.debuffs.string
      fa = foe.armor

      bs = buffs.string

      ?f = "acronian_scout"
        ?canBash()
          bash(Vantum Phoenix)

        :
          ?keepMask
            ?fds ! "chill:6"
              equipL @dIsword@
            :?fds ! "damage"
              equipL @dPsword1@
            :?fds ! "dot"
              equipL @dFsword@
            :
              ?bs = "berserk"
                equipL @sSword1@
              :
                equipL Vantum Phoenix

          :
            ?php = pmhp
              ?bs = "berserk"
                ldtF("sdmg")
              :
                doMoondial(Vantum Phoenix, fsword,0)
            :
              equipL Vantum Phoenix
              equipR @dLsword@


      :?f = "dysangelos" &
      ^fs ! 124
      ^!(fs = 107 & fdmg = 3)

        fdmg = foe.damage
        ft = foe.time
        
        trueDmg = fdmg
        ?fds = "damage"
          ?f = "phase3"
            trueDmg -= 8
          :
            trueDmg -= 4
        ?fds = "feeble"
          trueDmg -= 2*getDebuffLvl("feeble", true)
        
        
        ?canBash() & !dontDash
          bash(Vantum Phoenix)
        :?canDash() & !dontDash
          dash(Vantum Phoenix,dshield)

        :?armor < trueDmg & fs = 32 & (
        ^(f = "phase1" &
        ^  ((fds = "chill" & ft > 58) // about to attack, slowed down by chill debuff
        ^  |(48 < ft & ft < 52)      )) | // same, but w/o chill (sometimes it runs out right when attacking)
        ^(f = "phase3" & ft > 80)  ) // final phase, about to normal attack
          ldtF("aidActive")

        :?f ! "immune_to_debuff_damage"
        ^& fbs ! "buff_protection"
        ^& ls > 5
          ?keepMask
            ?fds ! "chill:6"
              ldtF("iDeb")
            :?fds ! "damage"
              ?f = "phase3"
                ldtF("pDeb2")
              :
                ldtF("pDeb1")
            :?fds ! "dot"
              ldtF("fDeb")
            :
              bossFight()
          :
            ?fds ! "damage"
              ?f = "phase3"
                ldtF("pDeb2")
              :
                ldtF("pDeb1")
            :
              bossFight()
        :
          bossFight()

// *******************************************************
//                  END OF "1-Rocky.txt"                  
// *******************************************************
