// *******************************************************
//                       FILE INFO
// *******************************************************


// Script for Deadwood Canyon


//IMPORTS


// *******************************************************
//                     utilities.txt                      
// *******************************************************


// VARIABLES:


//Units


var sec = 30 // frames
var scr = 69 // 1 screen = 69 units


//FUNCTIONS:


func myFormatDigital(frames)
  ?frames <= 0
    return "00:00"
  :
    var timeStr
    var secs
    var mins
    var secStr
    var minStr


    secs = frames/30
    mins = (frames/30)/60


    secs -= mins*60


    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins
      
    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
    
    return minStr + ":" + secStr




// *******************************************************
//                 END OF "utilities.txt"                 
// *******************************************************


// *******************************************************
//                    performanceV2.txt                   
// *******************************************************




// VARIABLES - definitions




//Location
var l = loc
var ls = loc.stars
var lavg = loc.averageTime
var lbt = loc.bestTime
var lb = loc.begin
var ll = loc.loop




// Foe
var f
f = foe
var fn
var fbs
var fds
var fd
var fc
var fs
var ft
var fhp
fhp = foe.hp
var fa
fa = foe.armor
var fdmg


// Time
var tt
tt = totaltime


// Item
var ip
ip = item.potion
var il
il = item.left
var ils
ils = item.left.state
var ilt
var ili


var ir
ir = item.right
var irs
irs = item.right.state
var irt
var iri


// Player stats
var php
var pmhp
var pa
var pma
var ds
var bs


// Ai
var aiE
var aiI
aiI = ai.idle




//screen
var si
si = screen.i




//resources
var rs // res.stone
var rw // res.wood
var rt // res.tar
var rb // res.bronze
var rk // res.ki
var rc // res.crystals




// Functions
var canAct
canAct = item.CanActivate()


// Cooldowns
var bladeCd = 80 * sec
var maskCd = 48 * sec
var armCd = 39 * sec
var taliCd = 5 * sec
var cindCd = 90 * sec


var bardCd = 30 * sec
var hammCd = 22 * sec
var mindCd = 12 * sec // currently not in use
var qstaffCd = 5 * sec + 15 // 5,5s
var dashCd = sec + 15 // 1,5s
var bashCd = 9 * sec


// Cast times
var castTime = sec


// Delays
var bladeDelay = 0
var maskDelay = 0
var armDelay = 0
var taliDelay = 0
var cindDelay = 0


var bardDelay = 0
var hammDelay = 0
var mindDelay = 0 // currently not in use
var qstaffDelay = 0
var dashDelay = 0
var bashDelay = 0


?tt < 3
  lb = loc.begin
  ll = loc.loop
?tt = 1
  lavg = loc.averageTime
  lbt = loc.bestTime


  bladeDelay = 0
  maskDelay = 0
  armDelay = 0
  taliDelay = 0
  cindDelay = 0


  bardDelay = 0
  hammDelay = 0
  mindDelay = 0 // currently not in use
  qstaffDelay = 0
  dashDelay = 0
  bashDelay = 0


// *******************************************************
//               END OF "performanceV2.txt"               
// *******************************************************


// *******************************************************
//                    MyBetterInfo.txt                    
// *******************************************************




// FUNCTIONS


func colorToHex(colorName)
  ?colorName = "red"
    return #FF0000
  :?colorName = "orange"
    return #FF7518
  :?colorName = "yellow"
    return #FFFF00
  :?colorName = "gold"
    return #E49B0F
  :?colorName = "blue"
    return #0000FF
  :?colorName = "cyan"
    return #00FFFF
  :?colorName = "magenta"
    return #FF00FF
  :?colorName = "pink"
    return #E0115F
  :?colorName = "purple"
    return #800080
  :?colorName = "violet"
    return #7F00FF
  :?colorName = "green"
    return #008000
  :?colorName = "darkGreen"
    return #023020
  :?colorName = "white"
    return #FFFFFF
  :?colorName = "gray"
    return #808080
  :?colorName = "black"
    return #000000
  :?colorName = "brown"
    return #7B3F00
  :?colorName = "turquoise" | colorName = "turquesa"
    return #40E0D0
  :?colorName = "rainbow" | colorName = "rgb"
    return #rainbow
  :
    >c-20,0,#red,ERROR: colorToHex() got unexisting color: @colorName@




func makeTextbox(x,y,w,h,txtStr,colorName,styleID)


  //declarations:
  var panel
  var txt


  //assignations:
  panel = ui.AddPanel()
  txt = ui.AddText(txtStr)




  //adding style and text to the panel:
  panel.style = styleID
  panel.Add(txt)


  //adding alignment
  panel.anchor = top_left
  panel.dock = top_left
  txt.anchor = top_left
  txt.dock = top_left


  //adding color
  ?colorName
    txt.color = colorToHex(colorName)
    panel.color = colorToHex(colorName)


  //adding position
  panel.x = x
  panel.y = y


  txt.x = 1
  txt.y = 1
  txt.w = w
  txt.h = h


  //adding wide and height
  panel.w = txt.w + 1
  panel.h = txt.h + 1


  return panel


func makeButton(x,y,w,h,anchor,dock,txtStr,colorName,styleID,actionFunc)
  var btn


  btn = ui.AddButton()


  btn.x = x
  btn.y = y


  btn.text = txtStr


  btn.w = string.Size(btn.text) + w
  btn.h = h


  ?anchor
    btn.anchor = anchor
  ?dock
    btn.dock = dock




  ?styleID
    btn.style = styleID


  ?colorName
    var colorID = colorToHex(colorName)
    btn.tcolor = colorID
    btn.bcolor = colorID
    btn.hcolor = colorID
  
  btn.SetPressed(actionFunc)


  return btn




func showStrCentered(str,y,maxW,colorName)
  ?string.Size(str) <= maxW
    >c@-(string.Size(str)-1)/2@,@y@,@colorToHex(colorName)@,@str@
  :
    var arrStr = string.Break(str,maxW)
    ?arrStr
      for i = 0 .. arrStr.Count() - 1
        >c@-(string.Size(str)-1)/2@,@y-((arrStr.Count()-1))/2+i@,@colorToHex(colorName)@,@arrStr[i]@


  return


// *******************************************************
//               END OF "MyBetterInfo.txt"                
// *******************************************************


// *******************************************************
//                       Combat.txt                       
// *******************************************************


// VARIABLES




// Status


var midhp = maxhp / 2
var lowhp = maxhp / 3
var hihp = (4 * maxhp) / 5




// FUNCTIONS






// Stats




/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getBuffInfo(nameid,inFoe,infoIndex)
  // if inFoe = true, checks foe's buffs, else, player's buffs
  var info
  var buffFound
  var arrBuffs


  ?inFoe
    arrBuffs = string.Split(fbs,",", true)
  :
    arrBuffs = string.Split(bs,",", true)
    
  ?arrBuffs & !buffFound
    for buff : arrBuffs
      ?buff = nameid
        var arrInfo = string.Split(buff,":",true)


        ?0 <= infoIndex & infoIndex <= 3
          info = int.Parse(arrInfo[infoIndex])


        buffFound = true


    ?buffFound = true
      return info
    :
      return 0


/* - arrInfo[0] is symbol
   - arrInfo[1] is id
   - arrInfo[2] is stack count
   - arrInfo[3] is remaining duration on first stack */
func getDebuffLvl(nameid,inFoe)
  // if inFoe = true, checks foe's debuffs, else, player's debuffs
  var lvl
  var debuffFound
  var arrDebuffs


  ?inFoe
    arrDebuffs = string.Split(fds,",", true)
  :
    arrDebuffs = string.Split(ds,",", true)


  ?arrDebuffs & !debuffFound
    for debuff : arrDebuffs
      ?debuff = nameid
        var arrInfo = string.Split(debuff,":",true)


        lvl = int.Parse(arrInfo[2])
        debuffFound = true


    ?debuffFound = true
      return lvl
    :
      return 0




func getFoeTotalHP()
  return fhp + fa






// Lost items




func canUseBlade()
  return tt >= bladeDelay & canAct


// cannot be interrupted, doesn't need a cooldown check
func useBlade()
  equip blade
  activate R


  bladeDelay = tt + bladeCd


  return


/* Checks if Blade of the Fallen God
can be used in 2 screens of distance,
according to a certain screen index. */
func canUseBladeDS(nScreen)
  return canUseBlade()
  ^& si = nScreen


var slideCount = 0 // counter to give screen.Next() time to slide
func useBladeDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useBlade()
      screen.ResetOffset()
      return




func canUseArm()
  return tt >= armDelay &
  ^3 < fd & fd < 7
  ^& canAct


func useArm()
  equip arm
  activate R


  armDelay = tt + armCd


  return




func canUseMask()
  return tt >= maskDelay & canAct


func useMask()
  equipL triskelion
  equipR mask
  activate R


  maskDelay = tt + maskCd


  return


func canUseMaskDS(nScreen)
  return canUseMask()
  ^& si = nScreen


func useMaskDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useMask()
      screen.ResetOffset()
      return






func canUseTali()
  return summon.count = 0 &
  ^tt >= taliDelay &
  ^canAct |
  ^(il = talisman & ils = 2) |
  ^(ir = talisman & irs = 2)


func canHideTali()
  return summon.count > 0 & summon.GetId() = "cinderwisp"
  ^& tt >= taliDelay
  ^& canAct |
  ^(il = talisman & ils = 2) |
  ^(ir = talisman & irs = 2)


func useTali(hand)
  ?hand = "l"
    equipL talisman
    activate L
  :?hand = "r"
    equipR talisman
    activate R


  taliDelay = tt + taliCd + castTime


  return


/* Checks if you can use the cinderwisp's "devour"
ability. */
func canUseCind()
  return summon.count >= 1
  ^& summon.GetId() = "cinderwisp"
  ^& tt >= cindDelay & canAct


/* Checks if the estimated damage of
cinderwisp's "devour" ability will kill the foe,
leaving a damage margin.
  - cindDmg: represents the damage the cinderwisp does,
             which will be multiplied by each ignition
             debuff applied.
  - margin: number representing a health margin to add
            to the remaining foe's health. This is
            necessary because the ability has a cast time
            that will alter the estimations done here.
            Send 0 if you don't want to use a margin. */
func canKillCind(cindDmg,margin)
  return getFoeTotalHP() <= (getDebuffLvl(ignition,true) * cindDmg) + margin


func useCind()
  activate cinderwisp
  cindDelay = tt + cindCd + castTime
  return




/* Checks if you can use the
bashing shield's ability. */
func canBash()
  return tt >= bashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct


func bash(lItem)
  equipL @lItem@
  equipR bashing shield


  bashDelay = tt + bashCd


  return








// Special Weapons




func canUseHamm()
  return tt >= hammDelay &
  ^canAct |
  ^(ir = heavy hammer &
  ^irs = 2)


var hammCdSlower
func canUseHamm2()
  hammCdSlower = item.GetCooldown("hammer") <= 0
  return hammCdSlower &
  ^canAct |
  ^(ir = "heavy hammer" &
  ^irs = 2)


func useHamm()
  equip heavy hammer
  activate R


  hammDelay = tt + hammCd + castTime


  return




func canUseBard()
  return tt >= bardDelay &
  ^canAct |
  ^(ir = bardiche &
  ^irs = 2)


var bardCdSlower
func canUseBard2()
  bardCdSlower = item.GetCooldown("bardiche") <= 0
  return bardCdSlower &
  ^canAct |
  ^(ir = "bardiche" &
  ^irs = 2)


func useBard(yourBard)
  ?fd < 10
    equip @yourBard@
    activate R


    bardDelay = tt + bardCd + castTime


  return




/* Checks if you can use the
dashing shield's ability. */
func canDash()
  return tt >= dashDelay & !aiI
  ^& 11 <= fd & fd <= 15
  ^& canAct


func dash(lItem,yourDshield)
  equipL @lItem@
  equipR @yourDshield@


  dashDelay = tt + dashCd


  return




func canUseQstaff()
  ?tt >= qstaffDelay


    return canAct |
    ^(ir = quarterstaff
    ^& irs = 2)
  :
    return false


// recieves a string
func useQstaff(yourQstaff)
  equip @yourQstaff@
  activate R


  qstaffDelay = tt + qstaffCd


  return


func canUseMind()
  return item.GetCooldown("mind") <= 0 & canAct








// Tools




func canUseHatchet()
  return item.GetCooldown("hatchet") <= 0
  ^& canAct
  ^& harvest.distance < 5
  ^& ir = hatchet


func useHatchet()
  activate R
  return








// Potions




func canUsePot()
  return ip ! empty & canAct


/* Determines if a damage buff potion
is brewed. Generally used for bosses.
Potions related:
  - berserk
  - lucky */
func canUsePotDmg()
  return canUsePot() &
  ^(ip = berserk | ip = lucky)








// Others




var moonTimer = 0
var moonFrame
func doMoondial(weapon1, weapon2, mode)
  ?mode = 0 // Normal moondialing
    moonTimer++
    moonFrame = moonTimer % 3


    ?moonFrame = 1
      equipL moon
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@


  :?mode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moonTimer++
    moonFrame = moonTimer % 4


    ?moonFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon1@
    :?moonFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moonFrame = 4
      equipL moon
      equipR @weapon2@
  
  :?mode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@


  :?mode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    ?fd <= 5
      equipL moon
    :
      equipL @weapon2@
    equipR @weapon1@




  return


// *******************************************************
//                  END OF "Combat.txt"                   
// *******************************************************


// *******************************************************
//                     MyArsenal.txt                      
// *******************************************************


// VARIABLES:




/* renamed:


Vantum Phoenix = fire sword D *max
Speedy Hammer = stone hammer *max
Kubikiribocho = bardiche *max (enchanted: crit) */


//poison:
var dPsword1 = "poison sword dP *max +13" // enchanted: speed
var dPsword2 = "poison sword dP +0" // enchanted: debuff
var dPwand = "poison wand dP *max"
//vigor:
var dLsword = "vigor sword dL *max"
var ahShield = "vigor shield ah *max"
var ahHammer = "vigor hammer ah *max"
//aether:
var dUsword1 = "aether sword dU *max +15 -big"
var dUSWORD2 = "big aether sword dU *max +15"
//fire:
var dFsword = "fire sword dF *max"
var fsword = "fire sword D *max"
var dFwand = "fire wand dF *max"
//ice:
var dIsword = "ice sword dI *max -big"
var dIwand1 = "ice wand dI *max +16"
//special weapons:
var dshield = "dashing shield *max"
var myqstaff = "quarterstaff golden"
var fastBard = "bardiche *max" // enchanted: speed
var cshield1 = "compound shield *max shiny"
var cshield2 = "compound shield *max -shiny"
var rbow = "repeating crossbow *max"






// Weapons damage


var bladeDmg = 310
var bladeRDmg = 93
var smiteMult = 7.6 // mult = multiplier


var armDmg = 44
var armRDmg = armDmg / 2
var maxArmBuffs = 3


var taliRDmg = 32 // multiplied by the amount of Ignition buffs
var maxIgnitions = 10


var hammDmg = 123


/* WARNING: These stats are for 
"Kubikiribocho" only, not for the
other bardiche! */
var bardDmg = 52
var bardRDmg = bardDmg * 10.8




// *******************************************************
//                 END OF "MyArsenal.txt"                 
// *******************************************************


// *******************************************************
//                    Speed_O_Meter.txt                   
// *******************************************************




// VARIABLES


// Times in seconds:
var ttDigital = myFormatDigital(tt)
var pb = myFormatDigital(lbt)
var avg = myFormatDigital(lavg)


// Variable updating frequency:
?tt % 30 = 0
  ttDigital = myFormatDigital(tt)
?ll
  pb = myFormatDigital(lbt)
  avg = myFormatDigital(lavg)






// FUNCTIONS


func speedOmeterUpdate(isSpeedrun)
  ?isSpeedrun
    return true
  :
    return tt % 30 = 0


func showSpeedOmeterUI(x,y,colorStr,isSpeedrun)
  var txt


  ?isSpeedrun
    txt = ui.AddText(
    ^"   SPEED-O-METER" + "\n" +
    ^"···················" + "\n" +
    ^" CUR " + ttDigital + " (" + tt + "f)" + "\n" +
    ^" PB  " + pb + " (" + lbt + "f)" + "\n" +
    ^" AVG " + avg + " (" + lavg + "f)"               )


  :
    txt = ui.AddText(
    ^"SPEED-O-METER" + "\n" +
    ^"·············" + "\n" +
    ^"  CUR " + ttDigital + "\n" +
    ^"  PB  " + pb + "\n" +
    ^"  AVG " + avg              )


  txt.anchor = top_left
  txt.dock = top_left


  txt.x = 1
  txt.y = 1


  ?isSpeedrun
    txt.w = 19
  :
    txt.w = 13
  txt.h = 5






  var panel


  panel = ui.AddPanel()
  panel.Add(txt)
  
  panel.style = -2
  
  panel.anchor = top_left
  panel.dock = top_left
  
  panel.x = x
  panel.y = y
  
  panel.w = txt.w + 2
  panel.h = txt.h + 2


  ?colorStr
    txt.color = colorStr
    panel.color = colorStr


  return panel


// *******************************************************
//               END OF "Speed_O_Meter.txt"               
// *******************************************************


?l = "Deadwood"


  // VARIABLES


  var keepMask = true
  var smiteScr = 1


  ?ll
    keepMask = false




  // FUNCTIONS:


  func harvFunc(btn)
    btnPressed = true
    ?btn = yesBtn
      choice = true
    : // btn = noBtn
      choice = false
    
    return


  func ldtF(mode)


    ?mode = "default"
      equipL triskelion
      ?!keepMask
        equipR @cshield1@
    :?mode = "armorRegen"
      equipL triskelion
      ?!keepMask
        equipR @cshield2@
    :?mode = "escape"
      equipL mind
      ?!keepMask
        equipR @cshield1@
    :?mode = "magnet"
      equipL star
      ?!keepMask
        equipR triskelion


    :?mode = "harv"
      ?!keepMask
        equipL moon
        equipR hatchet
      :
        equipL triskelion


    :?mode = "aidPassive"
      equipL ouroboros
      ?!keepMask
        equipR triskelion
    :?mode = "aidActive"
      equipL @vhammer3@
      ?!keepMask
        equipR @vshield2@




    :?mode = "unmkDmg"
      ?keepMask & fc > 1
        equipL @dUSWORD2@
      :
        equipL @dUsword1@
      ?!keepMask
        equipR @dUSWORD2@


    :?mode = "poenaStun"
      ?!keepMask
        equipL Speedy Hammer
        equipR Vantum Phoenix
      :
        equipL Speedy Hammer


    :?mode = "magic"
      ?keepMask
        equipL @dIwand1@
      :
        ?fds ! "damage"
          equipL @dPwand@
        :
          equipL @dFwand@
        equipR @dIwand1@


    :?mode = "rangedDmg"
      equip @rbow@


    :
      >c-10,0,#red,
      ^ERROR: ldtF() recieved incorrect mode: @mode@


    return




  // PROCEDURE:


  var somui = showSpeedOmeterUI(1,6,colorToHex("pink"),false)
  ?speedOmeterUpdate(false)
    showSpeedOmeterUI(1,6,colorToHex("pink"),false)




  var choice = false
  var btnPressed = false


  var yesBtn
  var noBtn


  var dontShowAgain = false




  ?!btnPressed
    ?!yesBtn
      yesBtn = makeButton(
      ^-5,9,4,4,null,null,
      ^"Yes",green,-5,harvFunc)
    ?!noBtn
      noBtn = makeButton(
      ^5,9,5,4,null,null,
      ^"No",red,-5,harvFunc)


    showStrCentered("Harvest trees?",6,30,yellow)


  :
    ?yesBtn
      yesBtn.Recycle()
      yesBtn = null
    ?noBtn
      noBtn.Recycle()
      noBtn = null


    ?!dontShowAgain
      var aux = tt + 3*sec
      ?tt < aux
        ?choice
          showStrCentered("Harvest trees is enabled",6,30,"green")
          ?keepMask
            showStrCentered("(Will start harvesting in the next run!)",7,40,"green")
        :
          showStrCentered("Harvest trees is disabled",6,30,"red")
      :
        ?!dontShowAgain
          dontShowAgain = true




  ?ils = 3
    equipL wand 0*
    equipL @il@
  ?irs = 3
    equipR @cshield1@
    equipR @ir@


  ?lb
    rs = res.stone
    rw = res.wood
    rb = res.bronze


    ?rb >= 10
      ?rw >= 10
        ?ip ! "berserk"
          brew wood + bronze
      :?rs >= 10
        ?ip ! "lucky"
          brew stone + bronze
      :
        loc.Leave()
    :
      loc.Leave()


  ?keepMask
    equipR mask


  ?lb | ll
    equipL triskelion
    equipR @cshield1@


  :?f ! "poena" & canUseTali()
    equipL triskelion
    useTali("r")


  :?canUsePotDmg() & keepMask
    activate potion


  :?choice & harvest.distance < 5
    ldtF("harv")
    ?canUseHatchet() & !keepMask
      useHatchet()


  :?pickup.distance < 15
    ldtF("magnet")


  :
    fd = foe.distance
    aiE = ai.enabled


    ?canUseQstaff()
      ?aiE & ir ! "hatchet"
      ^& ir ! "heavy hammer"
      ^& ir ! "bardiche"
      ^& ir ! Kubikiribocho
      ^& ((!canBash() & !canDash())
      ^| (fd < 11 | fd > 15))
        useQstaff(myqstaff)


    ?canUseBladeDS(smiteScr)
      useBladeDS()


    ?(f ! "tree_boss" & f ! "poena" & fd > 22)
    ^|(fd > 15)
      ?hp ! maxhp
        ldtF("aidPassive")
      :
        pa = armor
        ?14 <= pa & pa <= 29
          ldtF("default")
        :?pa < 14
          ldtF("armorRegen")
        :
          equipL triskelion
          equipR mask


    :
      ?f = "wasp" | f = "wasp_nest"
        fds = foe.debuffs.string


        ?fd <= 10 & canUseHamm()
          useHamm()


        :?fds ! "chill:6"
          ldtF("magic")
        :
          ldtF("rangedDmg")


      :?canBash()
        bash(dLsword)
      :?canDash()
        dash(dLsword,dshield)


      :
        fc = foe.GetCount(10)


        ?f ! "tree_boss" & f ! "poena"


          ?fc >= 5 & !canUseBlade()
          ^& canUseHamm()
            useHamm()


          :?f ! "immune_to_ranged"
            ldtF("magic")
          :
            ?fc > 1
              ldtF("unmkDmg")
            :
              ?keepMask
                ?fds ! "chill:6"
                  equipL @dIsword@
                :?fds ! "damage"
                  equipL @dPsword1@
                :?fds ! "dot"
                  equipL @dFsword@
                :
                  equipL @fsword@
              :
                ?fds ! "chill:6" |
                ^fds ! "damage" |
                ^fds ! "dot"
                  // Left hand:
                  ?fds ! "chill:6"
                    equipL @dIsword@
                  :
                    equipL @fsword@


                  // Right hand:
                  ?fds ! "damage"
                    equipR @dPsword1@
                  :?fds ! "dot"
                    equipR @dFsword@
                  :
                    equipR Vantum Phoenix
                :
                  bs = buffs.string
                  ?bs = "berserk"
                    doMoondial(Vantum Phoenix, fsword, 2)
                  :?bs = "lucky"
                    doMoondial(Vantum Phoenix, fsword, 0)


        : // ?foe = "tree_boss" | foe = "poena"
          ?ls > 5 & canUsePotDmg()
            activate potion


          :
            ?f = "phase1" // = "Xyloalgia"
              fds = foe.debuffs.string


              ?canUseMask()
                useMask()
              :?ls <= 5 & canUseBard()
                useBard(fastBard)


              :
                ?keepMask
                  ?fds ! "chill:6"
                    equipL @dIsword@
                  :?fds ! "damage"
                    equipL @dPsword1@
                  :?fds ! "dot"
                    equipL @dFsword@
                  :
                    equipL @fsword@
                :
                  ?fds ! "chill:6" |
                  ^fds ! "damage" |
                  ^fds ! "dot"
                    // Left hand:
                    ?fds ! "chill:6"
                      equipL @dIsword@
                    :
                      equipL @fsword@


                    // Right hand:
                    ?fds ! "damage"
                      equipR @dPsword1@
                    :?fds ! "dot"
                      equipR @dFsword@
                    :
                      equipR Vantum Phoenix
                  :
                    bs = buffs.string
                    ?bs = "berserk"
                      doMoondial(Vantum Phoenix, fsword, 2)
                    :?bs = "lucky"
                      doMoondial(Vantum Phoenix, fsword, 0)


            : // foe = "phase2" (poena)


              /* hide cinderwisp to avoid
              getting ignition debuff reflected */
              ?canHideTali()
                useTali("l")
              :
                fhp = foe.hp
                bs = buffs.string


                ?canUseBard() & fhp <= bardRDmg
                  useBard(Kubikiribocho)
                :
                  ?canUseHamm() &
                  ^fhp <= hammDmg +
                  ^(smiteMult * getBuffInfo("smite",false,2))
                    useHamm()
                  :
                    ldtF("poenaStun")


// *******************************************************
//                 END OF "2-Deadwood.txt"                
// *******************************************************